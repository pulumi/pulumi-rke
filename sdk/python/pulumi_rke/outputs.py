# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ClusterAuthentication',
    'ClusterAuthenticationWebhook',
    'ClusterAuthorization',
    'ClusterBastionHost',
    'ClusterCertificate',
    'ClusterCloudProvider',
    'ClusterCloudProviderAwsCloudConfig',
    'ClusterCloudProviderAwsCloudConfigGlobal',
    'ClusterCloudProviderAwsCloudConfigServiceOverride',
    'ClusterCloudProviderAwsCloudProvider',
    'ClusterCloudProviderAwsCloudProviderGlobal',
    'ClusterCloudProviderAwsCloudProviderServiceOverride',
    'ClusterCloudProviderAzureCloudConfig',
    'ClusterCloudProviderAzureCloudProvider',
    'ClusterCloudProviderOpenstackCloudConfig',
    'ClusterCloudProviderOpenstackCloudConfigBlockStorage',
    'ClusterCloudProviderOpenstackCloudConfigGlobal',
    'ClusterCloudProviderOpenstackCloudConfigLoadBalancer',
    'ClusterCloudProviderOpenstackCloudConfigMetadata',
    'ClusterCloudProviderOpenstackCloudConfigRoute',
    'ClusterCloudProviderOpenstackCloudProvider',
    'ClusterCloudProviderOpenstackCloudProviderBlockStorage',
    'ClusterCloudProviderOpenstackCloudProviderGlobal',
    'ClusterCloudProviderOpenstackCloudProviderLoadBalancer',
    'ClusterCloudProviderOpenstackCloudProviderMetadata',
    'ClusterCloudProviderOpenstackCloudProviderRoute',
    'ClusterCloudProviderVsphereCloudConfig',
    'ClusterCloudProviderVsphereCloudConfigDisk',
    'ClusterCloudProviderVsphereCloudConfigGlobal',
    'ClusterCloudProviderVsphereCloudConfigNetwork',
    'ClusterCloudProviderVsphereCloudConfigVirtualCenter',
    'ClusterCloudProviderVsphereCloudConfigWorkspace',
    'ClusterCloudProviderVsphereCloudProvider',
    'ClusterCloudProviderVsphereCloudProviderDisk',
    'ClusterCloudProviderVsphereCloudProviderGlobal',
    'ClusterCloudProviderVsphereCloudProviderNetwork',
    'ClusterCloudProviderVsphereCloudProviderVirtualCenter',
    'ClusterCloudProviderVsphereCloudProviderWorkspace',
    'ClusterControlPlaneHost',
    'ClusterDns',
    'ClusterDnsNodelocal',
    'ClusterEtcdHost',
    'ClusterInactiveHost',
    'ClusterIngress',
    'ClusterMonitoring',
    'ClusterNetwork',
    'ClusterNetworkAciNetworkProvider',
    'ClusterNetworkCalicoNetworkProvider',
    'ClusterNetworkCanalNetworkProvider',
    'ClusterNetworkFlannelNetworkProvider',
    'ClusterNetworkWeaveNetworkProvider',
    'ClusterNode',
    'ClusterNodeTaint',
    'ClusterPrivateRegistry',
    'ClusterRestore',
    'ClusterRotateCertificates',
    'ClusterRunningSystemImage',
    'ClusterServices',
    'ClusterServicesEtcd',
    'ClusterServicesEtcdBackupConfig',
    'ClusterServicesEtcdBackupConfigS3BackupConfig',
    'ClusterServicesEtcdDeprecated',
    'ClusterServicesEtcdDeprecatedBackupConfig',
    'ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig',
    'ClusterServicesKubeApi',
    'ClusterServicesKubeApiAuditLog',
    'ClusterServicesKubeApiAuditLogConfiguration',
    'ClusterServicesKubeApiDeprecated',
    'ClusterServicesKubeApiDeprecatedAuditLog',
    'ClusterServicesKubeApiDeprecatedAuditLogConfiguration',
    'ClusterServicesKubeApiDeprecatedEventRateLimit',
    'ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig',
    'ClusterServicesKubeApiEventRateLimit',
    'ClusterServicesKubeApiSecretsEncryptionConfig',
    'ClusterServicesKubeController',
    'ClusterServicesKubeControllerDeprecated',
    'ClusterServicesKubeProxyDeprecated',
    'ClusterServicesKubeSchedulerDeprecated',
    'ClusterServicesKubelet',
    'ClusterServicesKubeletDeprecated',
    'ClusterServicesKubeproxy',
    'ClusterServicesScheduler',
    'ClusterSystemImages',
    'ClusterUpgradeStrategy',
    'ClusterUpgradeStrategyDrainInput',
    'ClusterWorkerHost',
]

@pulumi.output_type
class ClusterAuthentication(dict):
    def __init__(__self__, *,
                 sans: Optional[Sequence[str]] = None,
                 strategy: Optional[str] = None,
                 webhook: Optional['outputs.ClusterAuthenticationWebhook'] = None):
        """
        :param Sequence[str] sans: List of additional hostnames and IPs to include in the api server PKI cert (list)
        :param str strategy: Authentication strategy that will be used in RKE k8s cluster. Default: `x509` (string)
        :param 'ClusterAuthenticationWebhookArgs' webhook: Webhook configuration options (list maxitem: 1)
        """
        ClusterAuthentication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sans=sans,
            strategy=strategy,
            webhook=webhook,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sans: Optional[Sequence[str]] = None,
             strategy: Optional[str] = None,
             webhook: Optional['outputs.ClusterAuthenticationWebhook'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if sans is not None:
            _setter("sans", sans)
        if strategy is not None:
            _setter("strategy", strategy)
        if webhook is not None:
            _setter("webhook", webhook)

    @property
    @pulumi.getter
    def sans(self) -> Optional[Sequence[str]]:
        """
        List of additional hostnames and IPs to include in the api server PKI cert (list)
        """
        return pulumi.get(self, "sans")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        Authentication strategy that will be used in RKE k8s cluster. Default: `x509` (string)
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def webhook(self) -> Optional['outputs.ClusterAuthenticationWebhook']:
        """
        Webhook configuration options (list maxitem: 1)
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class ClusterAuthenticationWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheTimeout":
            suggest = "cache_timeout"
        elif key == "configFile":
            suggest = "config_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAuthenticationWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAuthenticationWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAuthenticationWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_timeout: Optional[str] = None,
                 config_file: Optional[str] = None):
        """
        :param str cache_timeout: Controls how long to cache authentication decisions (string)
        :param str config_file: Multiline string that represent a custom webhook config file (string)
        """
        ClusterAuthenticationWebhook._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_timeout=cache_timeout,
            config_file=config_file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_timeout: Optional[str] = None,
             config_file: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_timeout is None and 'cacheTimeout' in kwargs:
            cache_timeout = kwargs['cacheTimeout']
        if config_file is None and 'configFile' in kwargs:
            config_file = kwargs['configFile']

        if cache_timeout is not None:
            _setter("cache_timeout", cache_timeout)
        if config_file is not None:
            _setter("config_file", config_file)

    @property
    @pulumi.getter(name="cacheTimeout")
    def cache_timeout(self) -> Optional[str]:
        """
        Controls how long to cache authentication decisions (string)
        """
        return pulumi.get(self, "cache_timeout")

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[str]:
        """
        Multiline string that represent a custom webhook config file (string)
        """
        return pulumi.get(self, "config_file")


@pulumi.output_type
class ClusterAuthorization(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 options: Optional[Mapping[str, Any]] = None):
        """
        :param str mode: RKE mode for authorization. `rbac` and `none` modes are available. Default `rbac` (string)
        :param Mapping[str, Any] options: Network provider options (map)
        """
        ClusterAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            options=options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             options: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if mode is not None:
            _setter("mode", mode)
        if options is not None:
            _setter("options", options)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        RKE mode for authorization. `rbac` and `none` modes are available. Default `rbac` (string)
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Network provider options (map)
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class ClusterBastionHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreProxyEnvVars":
            suggest = "ignore_proxy_env_vars"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshCert":
            suggest = "ssh_cert"
        elif key == "sshCertPath":
            suggest = "ssh_cert_path"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBastionHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBastionHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBastionHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 user: str,
                 ignore_proxy_env_vars: Optional[bool] = None,
                 port: Optional[str] = None,
                 ssh_agent_auth: Optional[bool] = None,
                 ssh_cert: Optional[str] = None,
                 ssh_cert_path: Optional[str] = None,
                 ssh_key: Optional[str] = None,
                 ssh_key_path: Optional[str] = None):
        """
        :param str address: Address ip for node (string)
        :param str user: Registry user (string)
        :param bool ignore_proxy_env_vars: Ignore proxy env vars at Bastion Host? Default: `false` (bool)
        :param str port: Port used for SSH communication (string)
        :param bool ssh_agent_auth: SSH Agent Auth enable (bool)
        :param str ssh_cert: SSH Certificate (string)
        :param str ssh_cert_path: SSH Certificate Path (string)
        :param str ssh_key: SSH Private Key (string)
        :param str ssh_key_path: SSH Private Key Path (string)
        """
        ClusterBastionHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            user=user,
            ignore_proxy_env_vars=ignore_proxy_env_vars,
            port=port,
            ssh_agent_auth=ssh_agent_auth,
            ssh_cert=ssh_cert,
            ssh_cert_path=ssh_cert_path,
            ssh_key=ssh_key,
            ssh_key_path=ssh_key_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             user: Optional[str] = None,
             ignore_proxy_env_vars: Optional[bool] = None,
             port: Optional[str] = None,
             ssh_agent_auth: Optional[bool] = None,
             ssh_cert: Optional[str] = None,
             ssh_cert_path: Optional[str] = None,
             ssh_key: Optional[str] = None,
             ssh_key_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")
        if ignore_proxy_env_vars is None and 'ignoreProxyEnvVars' in kwargs:
            ignore_proxy_env_vars = kwargs['ignoreProxyEnvVars']
        if ssh_agent_auth is None and 'sshAgentAuth' in kwargs:
            ssh_agent_auth = kwargs['sshAgentAuth']
        if ssh_cert is None and 'sshCert' in kwargs:
            ssh_cert = kwargs['sshCert']
        if ssh_cert_path is None and 'sshCertPath' in kwargs:
            ssh_cert_path = kwargs['sshCertPath']
        if ssh_key is None and 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']
        if ssh_key_path is None and 'sshKeyPath' in kwargs:
            ssh_key_path = kwargs['sshKeyPath']

        _setter("address", address)
        _setter("user", user)
        if ignore_proxy_env_vars is not None:
            _setter("ignore_proxy_env_vars", ignore_proxy_env_vars)
        if port is not None:
            _setter("port", port)
        if ssh_agent_auth is not None:
            _setter("ssh_agent_auth", ssh_agent_auth)
        if ssh_cert is not None:
            _setter("ssh_cert", ssh_cert)
        if ssh_cert_path is not None:
            _setter("ssh_cert_path", ssh_cert_path)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if ssh_key_path is not None:
            _setter("ssh_key_path", ssh_key_path)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="ignoreProxyEnvVars")
    def ignore_proxy_env_vars(self) -> Optional[bool]:
        """
        Ignore proxy env vars at Bastion Host? Default: `false` (bool)
        """
        return pulumi.get(self, "ignore_proxy_env_vars")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[bool]:
        """
        SSH Agent Auth enable (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @property
    @pulumi.getter(name="sshCert")
    def ssh_cert(self) -> Optional[str]:
        """
        SSH Certificate (string)
        """
        return pulumi.get(self, "ssh_cert")

    @property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[str]:
        """
        SSH Certificate Path (string)
        """
        return pulumi.get(self, "ssh_cert_path")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        """
        SSH Private Key (string)
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[str]:
        """
        SSH Private Key Path (string)
        """
        return pulumi.get(self, "ssh_key_path")


@pulumi.output_type
class ClusterCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "configEnvName":
            suggest = "config_env_name"
        elif key == "configPath":
            suggest = "config_path"
        elif key == "envName":
            suggest = "env_name"
        elif key == "keyEnvName":
            suggest = "key_env_name"
        elif key == "keyPath":
            suggest = "key_path"
        elif key == "ouName":
            suggest = "ou_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 common_name: Optional[str] = None,
                 config: Optional[str] = None,
                 config_env_name: Optional[str] = None,
                 config_path: Optional[str] = None,
                 env_name: Optional[str] = None,
                 id: Optional[str] = None,
                 key: Optional[str] = None,
                 key_env_name: Optional[str] = None,
                 key_path: Optional[str] = None,
                 name: Optional[str] = None,
                 ou_name: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str id: (Computed) The ID of the resource (string)
        :param str key: TLS key for etcd service (string)
        :param str name: Name of virtualcenter config for Vsphere Cloud Provider config (string)
        :param str path: Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        ClusterCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            common_name=common_name,
            config=config,
            config_env_name=config_env_name,
            config_path=config_path,
            env_name=env_name,
            id=id,
            key=key,
            key_env_name=key_env_name,
            key_path=key_path,
            name=name,
            ou_name=ou_name,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional[str] = None,
             common_name: Optional[str] = None,
             config: Optional[str] = None,
             config_env_name: Optional[str] = None,
             config_path: Optional[str] = None,
             env_name: Optional[str] = None,
             id: Optional[str] = None,
             key: Optional[str] = None,
             key_env_name: Optional[str] = None,
             key_path: Optional[str] = None,
             name: Optional[str] = None,
             ou_name: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if common_name is None and 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if config_env_name is None and 'configEnvName' in kwargs:
            config_env_name = kwargs['configEnvName']
        if config_path is None and 'configPath' in kwargs:
            config_path = kwargs['configPath']
        if env_name is None and 'envName' in kwargs:
            env_name = kwargs['envName']
        if key_env_name is None and 'keyEnvName' in kwargs:
            key_env_name = kwargs['keyEnvName']
        if key_path is None and 'keyPath' in kwargs:
            key_path = kwargs['keyPath']
        if ou_name is None and 'ouName' in kwargs:
            ou_name = kwargs['ouName']

        if certificate is not None:
            _setter("certificate", certificate)
        if common_name is not None:
            _setter("common_name", common_name)
        if config is not None:
            _setter("config", config)
        if config_env_name is not None:
            _setter("config_env_name", config_env_name)
        if config_path is not None:
            _setter("config_path", config_path)
        if env_name is not None:
            _setter("env_name", env_name)
        if id is not None:
            _setter("id", id)
        if key is not None:
            _setter("key", key)
        if key_env_name is not None:
            _setter("key_env_name", key_env_name)
        if key_path is not None:
            _setter("key_path", key_path)
        if name is not None:
            _setter("name", name)
        if ou_name is not None:
            _setter("ou_name", ou_name)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="configEnvName")
    def config_env_name(self) -> Optional[str]:
        return pulumi.get(self, "config_env_name")

    @property
    @pulumi.getter(name="configPath")
    def config_path(self) -> Optional[str]:
        return pulumi.get(self, "config_path")

    @property
    @pulumi.getter(name="envName")
    def env_name(self) -> Optional[str]:
        return pulumi.get(self, "env_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TLS key for etcd service (string)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="keyEnvName")
    def key_env_name(self) -> Optional[str]:
        return pulumi.get(self, "key_env_name")

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[str]:
        return pulumi.get(self, "key_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of virtualcenter config for Vsphere Cloud Provider config (string)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ouName")
    def ou_name(self) -> Optional[str]:
        return pulumi.get(self, "ou_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ClusterCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsCloudConfig":
            suggest = "aws_cloud_config"
        elif key == "awsCloudProvider":
            suggest = "aws_cloud_provider"
        elif key == "azureCloudConfig":
            suggest = "azure_cloud_config"
        elif key == "azureCloudProvider":
            suggest = "azure_cloud_provider"
        elif key == "customCloudConfig":
            suggest = "custom_cloud_config"
        elif key == "customCloudProvider":
            suggest = "custom_cloud_provider"
        elif key == "openstackCloudConfig":
            suggest = "openstack_cloud_config"
        elif key == "openstackCloudProvider":
            suggest = "openstack_cloud_provider"
        elif key == "vsphereCloudConfig":
            suggest = "vsphere_cloud_config"
        elif key == "vsphereCloudProvider":
            suggest = "vsphere_cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 aws_cloud_config: Optional['outputs.ClusterCloudProviderAwsCloudConfig'] = None,
                 aws_cloud_provider: Optional['outputs.ClusterCloudProviderAwsCloudProvider'] = None,
                 azure_cloud_config: Optional['outputs.ClusterCloudProviderAzureCloudConfig'] = None,
                 azure_cloud_provider: Optional['outputs.ClusterCloudProviderAzureCloudProvider'] = None,
                 custom_cloud_config: Optional[str] = None,
                 custom_cloud_provider: Optional[str] = None,
                 openstack_cloud_config: Optional['outputs.ClusterCloudProviderOpenstackCloudConfig'] = None,
                 openstack_cloud_provider: Optional['outputs.ClusterCloudProviderOpenstackCloudProvider'] = None,
                 vsphere_cloud_config: Optional['outputs.ClusterCloudProviderVsphereCloudConfig'] = None,
                 vsphere_cloud_provider: Optional['outputs.ClusterCloudProviderVsphereCloudProvider'] = None):
        """
        :param str name: Name of virtualcenter config for Vsphere Cloud Provider config (string)
        :param 'ClusterCloudProviderAwsCloudConfigArgs' aws_cloud_config: Use aws_cloud_provider instead
        :param 'ClusterCloudProviderAwsCloudProviderArgs' aws_cloud_provider: AWS Cloud Provider config [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        :param 'ClusterCloudProviderAzureCloudConfigArgs' azure_cloud_config: Use azure_cloud_provider instead
        :param 'ClusterCloudProviderAzureCloudProviderArgs' azure_cloud_provider: Azure Cloud Provider config [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        :param str custom_cloud_config: Use custom_cloud_provider instead
        :param str custom_cloud_provider: Custom Cloud Provider config (string)
        :param 'ClusterCloudProviderOpenstackCloudConfigArgs' openstack_cloud_config: Use openstack_cloud_provider instead
        :param 'ClusterCloudProviderOpenstackCloudProviderArgs' openstack_cloud_provider: Openstack Cloud Provider config [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudConfigArgs' vsphere_cloud_config: Use vsphere_cloud_provider instead
        :param 'ClusterCloudProviderVsphereCloudProviderArgs' vsphere_cloud_provider: Vsphere Cloud Provider config [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        ClusterCloudProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            aws_cloud_config=aws_cloud_config,
            aws_cloud_provider=aws_cloud_provider,
            azure_cloud_config=azure_cloud_config,
            azure_cloud_provider=azure_cloud_provider,
            custom_cloud_config=custom_cloud_config,
            custom_cloud_provider=custom_cloud_provider,
            openstack_cloud_config=openstack_cloud_config,
            openstack_cloud_provider=openstack_cloud_provider,
            vsphere_cloud_config=vsphere_cloud_config,
            vsphere_cloud_provider=vsphere_cloud_provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             aws_cloud_config: Optional['outputs.ClusterCloudProviderAwsCloudConfig'] = None,
             aws_cloud_provider: Optional['outputs.ClusterCloudProviderAwsCloudProvider'] = None,
             azure_cloud_config: Optional['outputs.ClusterCloudProviderAzureCloudConfig'] = None,
             azure_cloud_provider: Optional['outputs.ClusterCloudProviderAzureCloudProvider'] = None,
             custom_cloud_config: Optional[str] = None,
             custom_cloud_provider: Optional[str] = None,
             openstack_cloud_config: Optional['outputs.ClusterCloudProviderOpenstackCloudConfig'] = None,
             openstack_cloud_provider: Optional['outputs.ClusterCloudProviderOpenstackCloudProvider'] = None,
             vsphere_cloud_config: Optional['outputs.ClusterCloudProviderVsphereCloudConfig'] = None,
             vsphere_cloud_provider: Optional['outputs.ClusterCloudProviderVsphereCloudProvider'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if aws_cloud_config is None and 'awsCloudConfig' in kwargs:
            aws_cloud_config = kwargs['awsCloudConfig']
        if aws_cloud_provider is None and 'awsCloudProvider' in kwargs:
            aws_cloud_provider = kwargs['awsCloudProvider']
        if azure_cloud_config is None and 'azureCloudConfig' in kwargs:
            azure_cloud_config = kwargs['azureCloudConfig']
        if azure_cloud_provider is None and 'azureCloudProvider' in kwargs:
            azure_cloud_provider = kwargs['azureCloudProvider']
        if custom_cloud_config is None and 'customCloudConfig' in kwargs:
            custom_cloud_config = kwargs['customCloudConfig']
        if custom_cloud_provider is None and 'customCloudProvider' in kwargs:
            custom_cloud_provider = kwargs['customCloudProvider']
        if openstack_cloud_config is None and 'openstackCloudConfig' in kwargs:
            openstack_cloud_config = kwargs['openstackCloudConfig']
        if openstack_cloud_provider is None and 'openstackCloudProvider' in kwargs:
            openstack_cloud_provider = kwargs['openstackCloudProvider']
        if vsphere_cloud_config is None and 'vsphereCloudConfig' in kwargs:
            vsphere_cloud_config = kwargs['vsphereCloudConfig']
        if vsphere_cloud_provider is None and 'vsphereCloudProvider' in kwargs:
            vsphere_cloud_provider = kwargs['vsphereCloudProvider']

        _setter("name", name)
        if aws_cloud_config is not None:
            _setter("aws_cloud_config", aws_cloud_config)
        if aws_cloud_provider is not None:
            _setter("aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_config is not None:
            _setter("azure_cloud_config", azure_cloud_config)
        if azure_cloud_provider is not None:
            _setter("azure_cloud_provider", azure_cloud_provider)
        if custom_cloud_config is not None:
            _setter("custom_cloud_config", custom_cloud_config)
        if custom_cloud_provider is not None:
            _setter("custom_cloud_provider", custom_cloud_provider)
        if openstack_cloud_config is not None:
            _setter("openstack_cloud_config", openstack_cloud_config)
        if openstack_cloud_provider is not None:
            _setter("openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_config is not None:
            _setter("vsphere_cloud_config", vsphere_cloud_config)
        if vsphere_cloud_provider is not None:
            _setter("vsphere_cloud_provider", vsphere_cloud_provider)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of virtualcenter config for Vsphere Cloud Provider config (string)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="awsCloudConfig")
    def aws_cloud_config(self) -> Optional['outputs.ClusterCloudProviderAwsCloudConfig']:
        """
        Use aws_cloud_provider instead
        """
        warnings.warn("""Use aws_cloud_provider instead""", DeprecationWarning)
        pulumi.log.warn("""aws_cloud_config is deprecated: Use aws_cloud_provider instead""")

        return pulumi.get(self, "aws_cloud_config")

    @property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional['outputs.ClusterCloudProviderAwsCloudProvider']:
        """
        AWS Cloud Provider config [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        """
        return pulumi.get(self, "aws_cloud_provider")

    @property
    @pulumi.getter(name="azureCloudConfig")
    def azure_cloud_config(self) -> Optional['outputs.ClusterCloudProviderAzureCloudConfig']:
        """
        Use azure_cloud_provider instead
        """
        warnings.warn("""Use azure_cloud_provider instead""", DeprecationWarning)
        pulumi.log.warn("""azure_cloud_config is deprecated: Use azure_cloud_provider instead""")

        return pulumi.get(self, "azure_cloud_config")

    @property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional['outputs.ClusterCloudProviderAzureCloudProvider']:
        """
        Azure Cloud Provider config [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        """
        return pulumi.get(self, "azure_cloud_provider")

    @property
    @pulumi.getter(name="customCloudConfig")
    def custom_cloud_config(self) -> Optional[str]:
        """
        Use custom_cloud_provider instead
        """
        warnings.warn("""Use custom_cloud_provider instead""", DeprecationWarning)
        pulumi.log.warn("""custom_cloud_config is deprecated: Use custom_cloud_provider instead""")

        return pulumi.get(self, "custom_cloud_config")

    @property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> Optional[str]:
        """
        Custom Cloud Provider config (string)
        """
        return pulumi.get(self, "custom_cloud_provider")

    @property
    @pulumi.getter(name="openstackCloudConfig")
    def openstack_cloud_config(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudConfig']:
        """
        Use openstack_cloud_provider instead
        """
        warnings.warn("""Use openstack_cloud_provider instead""", DeprecationWarning)
        pulumi.log.warn("""openstack_cloud_config is deprecated: Use openstack_cloud_provider instead""")

        return pulumi.get(self, "openstack_cloud_config")

    @property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudProvider']:
        """
        Openstack Cloud Provider config [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        """
        return pulumi.get(self, "openstack_cloud_provider")

    @property
    @pulumi.getter(name="vsphereCloudConfig")
    def vsphere_cloud_config(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudConfig']:
        """
        Use vsphere_cloud_provider instead
        """
        warnings.warn("""Use vsphere_cloud_provider instead""", DeprecationWarning)
        pulumi.log.warn("""vsphere_cloud_config is deprecated: Use vsphere_cloud_provider instead""")

        return pulumi.get(self, "vsphere_cloud_config")

    @property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudProvider']:
        """
        Vsphere Cloud Provider config [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        return pulumi.get(self, "vsphere_cloud_provider")


@pulumi.output_type
class ClusterCloudProviderAwsCloudConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "serviceOverrides":
            suggest = "service_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: Optional['outputs.ClusterCloudProviderAwsCloudConfigGlobal'] = None,
                 service_overrides: Optional[Sequence['outputs.ClusterCloudProviderAwsCloudConfigServiceOverride']] = None):
        """
        :param 'ClusterCloudProviderAwsCloudConfigGlobalArgs' global_: (list maxitems:1)
        :param Sequence['ClusterCloudProviderAwsCloudConfigServiceOverrideArgs'] service_overrides: (list)
        """
        ClusterCloudProviderAwsCloudConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            global_=global_,
            service_overrides=service_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             global_: Optional['outputs.ClusterCloudProviderAwsCloudConfigGlobal'] = None,
             service_overrides: Optional[Sequence['outputs.ClusterCloudProviderAwsCloudConfigServiceOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']
        if service_overrides is None and 'serviceOverrides' in kwargs:
            service_overrides = kwargs['serviceOverrides']

        if global_ is not None:
            _setter("global_", global_)
        if service_overrides is not None:
            _setter("service_overrides", service_overrides)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterCloudProviderAwsCloudConfigGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.ClusterCloudProviderAwsCloudConfigServiceOverride']]:
        """
        (list)
        """
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class ClusterCloudProviderAwsCloudConfigGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSecurityGroupIngress":
            suggest = "disable_security_group_ingress"
        elif key == "disableStrictZoneCheck":
            suggest = "disable_strict_zone_check"
        elif key == "elbSecurityGroup":
            suggest = "elb_security_group"
        elif key == "kubernetesClusterId":
            suggest = "kubernetes_cluster_id"
        elif key == "kubernetesClusterTag":
            suggest = "kubernetes_cluster_tag"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "routeTableId":
            suggest = "route_table_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudConfigGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudConfigGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudConfigGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[bool] = None,
                 disable_strict_zone_check: Optional[bool] = None,
                 elb_security_group: Optional[str] = None,
                 kubernetes_cluster_id: Optional[str] = None,
                 kubernetes_cluster_tag: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 route_table_id: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param bool disable_security_group_ingress: Disables the automatic ingress creation. Default `false` (bool)
        :param bool disable_strict_zone_check: Setting this to true will disable the check and provide a warning that the check was skipped. Default `false` (bool)
        :param str elb_security_group: Use these ELB security groups instead create new (string)
        :param str kubernetes_cluster_id: The cluster id we'll use to identify our cluster resources (string)
        :param str kubernetes_cluster_tag: Legacy cluster id we'll use to identify our cluster resources (string)
        :param str role_arn: IAM role to assume when interaction with AWS APIs (string)
        :param str route_table_id: Enables using a specific RouteTable (string)
        :param str subnet_id: (string)
        :param str vpc: The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided (string)
        :param str zone: The AWS zone (string)
        """
        ClusterCloudProviderAwsCloudConfigGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_security_group_ingress=disable_security_group_ingress,
            disable_strict_zone_check=disable_strict_zone_check,
            elb_security_group=elb_security_group,
            kubernetes_cluster_id=kubernetes_cluster_id,
            kubernetes_cluster_tag=kubernetes_cluster_tag,
            role_arn=role_arn,
            route_table_id=route_table_id,
            subnet_id=subnet_id,
            vpc=vpc,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_security_group_ingress: Optional[bool] = None,
             disable_strict_zone_check: Optional[bool] = None,
             elb_security_group: Optional[str] = None,
             kubernetes_cluster_id: Optional[str] = None,
             kubernetes_cluster_tag: Optional[str] = None,
             role_arn: Optional[str] = None,
             route_table_id: Optional[str] = None,
             subnet_id: Optional[str] = None,
             vpc: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_security_group_ingress is None and 'disableSecurityGroupIngress' in kwargs:
            disable_security_group_ingress = kwargs['disableSecurityGroupIngress']
        if disable_strict_zone_check is None and 'disableStrictZoneCheck' in kwargs:
            disable_strict_zone_check = kwargs['disableStrictZoneCheck']
        if elb_security_group is None and 'elbSecurityGroup' in kwargs:
            elb_security_group = kwargs['elbSecurityGroup']
        if kubernetes_cluster_id is None and 'kubernetesClusterId' in kwargs:
            kubernetes_cluster_id = kwargs['kubernetesClusterId']
        if kubernetes_cluster_tag is None and 'kubernetesClusterTag' in kwargs:
            kubernetes_cluster_tag = kwargs['kubernetesClusterTag']
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if route_table_id is None and 'routeTableId' in kwargs:
            route_table_id = kwargs['routeTableId']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if disable_security_group_ingress is not None:
            _setter("disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            _setter("disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            _setter("elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            _setter("kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            _setter("kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if route_table_id is not None:
            _setter("route_table_id", route_table_id)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if vpc is not None:
            _setter("vpc", vpc)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[bool]:
        """
        Disables the automatic ingress creation. Default `false` (bool)
        """
        return pulumi.get(self, "disable_security_group_ingress")

    @property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[bool]:
        """
        Setting this to true will disable the check and provide a warning that the check was skipped. Default `false` (bool)
        """
        return pulumi.get(self, "disable_strict_zone_check")

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[str]:
        """
        Use these ELB security groups instead create new (string)
        """
        return pulumi.get(self, "elb_security_group")

    @property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[str]:
        """
        The cluster id we'll use to identify our cluster resources (string)
        """
        return pulumi.get(self, "kubernetes_cluster_id")

    @property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[str]:
        """
        Legacy cluster id we'll use to identify our cluster resources (string)
        """
        return pulumi.get(self, "kubernetes_cluster_tag")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        IAM role to assume when interaction with AWS APIs (string)
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[str]:
        """
        Enables using a specific RouteTable (string)
        """
        return pulumi.get(self, "route_table_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def vpc(self) -> Optional[str]:
        """
        The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided (string)
        """
        return pulumi.get(self, "vpc")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The AWS zone (string)
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterCloudProviderAwsCloudConfigServiceOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingMethod":
            suggest = "signing_method"
        elif key == "signingName":
            suggest = "signing_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudConfigServiceOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudConfigServiceOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudConfigServiceOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: str,
                 key: Optional[str] = None,
                 region: Optional[str] = None,
                 signing_method: Optional[str] = None,
                 signing_name: Optional[str] = None,
                 signing_region: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str service: (string)
        :param str key: TLS key for etcd service (string)
        :param str region: Region for S3 service (string)
        :param str signing_method: (string)
        :param str signing_name: (string)
        :param str signing_region: (string)
        :param str url: Registry URL (string)
        """
        ClusterCloudProviderAwsCloudConfigServiceOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service=service,
            key=key,
            region=region,
            signing_method=signing_method,
            signing_name=signing_name,
            signing_region=signing_region,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service: Optional[str] = None,
             key: Optional[str] = None,
             region: Optional[str] = None,
             signing_method: Optional[str] = None,
             signing_name: Optional[str] = None,
             signing_region: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service is None:
            raise TypeError("Missing 'service' argument")
        if signing_method is None and 'signingMethod' in kwargs:
            signing_method = kwargs['signingMethod']
        if signing_name is None and 'signingName' in kwargs:
            signing_name = kwargs['signingName']
        if signing_region is None and 'signingRegion' in kwargs:
            signing_region = kwargs['signingRegion']

        _setter("service", service)
        if key is not None:
            _setter("key", key)
        if region is not None:
            _setter("region", region)
        if signing_method is not None:
            _setter("signing_method", signing_method)
        if signing_name is not None:
            _setter("signing_name", signing_name)
        if signing_region is not None:
            _setter("signing_region", signing_region)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TLS key for etcd service (string)
        """
        warnings.warn("""Use service instead""", DeprecationWarning)
        pulumi.log.warn("""key is deprecated: Use service instead""")

        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_method")

    @property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_name")

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_region")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClusterCloudProviderAwsCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "serviceOverrides":
            suggest = "service_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: Optional['outputs.ClusterCloudProviderAwsCloudProviderGlobal'] = None,
                 service_overrides: Optional[Sequence['outputs.ClusterCloudProviderAwsCloudProviderServiceOverride']] = None):
        """
        :param 'ClusterCloudProviderAwsCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param Sequence['ClusterCloudProviderAwsCloudProviderServiceOverrideArgs'] service_overrides: (list)
        """
        ClusterCloudProviderAwsCloudProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            global_=global_,
            service_overrides=service_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             global_: Optional['outputs.ClusterCloudProviderAwsCloudProviderGlobal'] = None,
             service_overrides: Optional[Sequence['outputs.ClusterCloudProviderAwsCloudProviderServiceOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']
        if service_overrides is None and 'serviceOverrides' in kwargs:
            service_overrides = kwargs['serviceOverrides']

        if global_ is not None:
            _setter("global_", global_)
        if service_overrides is not None:
            _setter("service_overrides", service_overrides)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterCloudProviderAwsCloudProviderGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.ClusterCloudProviderAwsCloudProviderServiceOverride']]:
        """
        (list)
        """
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class ClusterCloudProviderAwsCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSecurityGroupIngress":
            suggest = "disable_security_group_ingress"
        elif key == "disableStrictZoneCheck":
            suggest = "disable_strict_zone_check"
        elif key == "elbSecurityGroup":
            suggest = "elb_security_group"
        elif key == "kubernetesClusterId":
            suggest = "kubernetes_cluster_id"
        elif key == "kubernetesClusterTag":
            suggest = "kubernetes_cluster_tag"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "routeTableId":
            suggest = "route_table_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[bool] = None,
                 disable_strict_zone_check: Optional[bool] = None,
                 elb_security_group: Optional[str] = None,
                 kubernetes_cluster_id: Optional[str] = None,
                 kubernetes_cluster_tag: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 route_table_id: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param bool disable_security_group_ingress: Disables the automatic ingress creation. Default `false` (bool)
        :param bool disable_strict_zone_check: Setting this to true will disable the check and provide a warning that the check was skipped. Default `false` (bool)
        :param str elb_security_group: Use these ELB security groups instead create new (string)
        :param str kubernetes_cluster_id: The cluster id we'll use to identify our cluster resources (string)
        :param str kubernetes_cluster_tag: Legacy cluster id we'll use to identify our cluster resources (string)
        :param str role_arn: IAM role to assume when interaction with AWS APIs (string)
        :param str route_table_id: Enables using a specific RouteTable (string)
        :param str subnet_id: (string)
        :param str vpc: The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided (string)
        :param str zone: The AWS zone (string)
        """
        ClusterCloudProviderAwsCloudProviderGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_security_group_ingress=disable_security_group_ingress,
            disable_strict_zone_check=disable_strict_zone_check,
            elb_security_group=elb_security_group,
            kubernetes_cluster_id=kubernetes_cluster_id,
            kubernetes_cluster_tag=kubernetes_cluster_tag,
            role_arn=role_arn,
            route_table_id=route_table_id,
            subnet_id=subnet_id,
            vpc=vpc,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_security_group_ingress: Optional[bool] = None,
             disable_strict_zone_check: Optional[bool] = None,
             elb_security_group: Optional[str] = None,
             kubernetes_cluster_id: Optional[str] = None,
             kubernetes_cluster_tag: Optional[str] = None,
             role_arn: Optional[str] = None,
             route_table_id: Optional[str] = None,
             subnet_id: Optional[str] = None,
             vpc: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_security_group_ingress is None and 'disableSecurityGroupIngress' in kwargs:
            disable_security_group_ingress = kwargs['disableSecurityGroupIngress']
        if disable_strict_zone_check is None and 'disableStrictZoneCheck' in kwargs:
            disable_strict_zone_check = kwargs['disableStrictZoneCheck']
        if elb_security_group is None and 'elbSecurityGroup' in kwargs:
            elb_security_group = kwargs['elbSecurityGroup']
        if kubernetes_cluster_id is None and 'kubernetesClusterId' in kwargs:
            kubernetes_cluster_id = kwargs['kubernetesClusterId']
        if kubernetes_cluster_tag is None and 'kubernetesClusterTag' in kwargs:
            kubernetes_cluster_tag = kwargs['kubernetesClusterTag']
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if route_table_id is None and 'routeTableId' in kwargs:
            route_table_id = kwargs['routeTableId']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if disable_security_group_ingress is not None:
            _setter("disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            _setter("disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            _setter("elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            _setter("kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            _setter("kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if route_table_id is not None:
            _setter("route_table_id", route_table_id)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if vpc is not None:
            _setter("vpc", vpc)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[bool]:
        """
        Disables the automatic ingress creation. Default `false` (bool)
        """
        return pulumi.get(self, "disable_security_group_ingress")

    @property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[bool]:
        """
        Setting this to true will disable the check and provide a warning that the check was skipped. Default `false` (bool)
        """
        return pulumi.get(self, "disable_strict_zone_check")

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[str]:
        """
        Use these ELB security groups instead create new (string)
        """
        return pulumi.get(self, "elb_security_group")

    @property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[str]:
        """
        The cluster id we'll use to identify our cluster resources (string)
        """
        return pulumi.get(self, "kubernetes_cluster_id")

    @property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[str]:
        """
        Legacy cluster id we'll use to identify our cluster resources (string)
        """
        return pulumi.get(self, "kubernetes_cluster_tag")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        IAM role to assume when interaction with AWS APIs (string)
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[str]:
        """
        Enables using a specific RouteTable (string)
        """
        return pulumi.get(self, "route_table_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def vpc(self) -> Optional[str]:
        """
        The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided (string)
        """
        return pulumi.get(self, "vpc")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The AWS zone (string)
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterCloudProviderAwsCloudProviderServiceOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingMethod":
            suggest = "signing_method"
        elif key == "signingName":
            suggest = "signing_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAwsCloudProviderServiceOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: str,
                 key: Optional[str] = None,
                 region: Optional[str] = None,
                 signing_method: Optional[str] = None,
                 signing_name: Optional[str] = None,
                 signing_region: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str service: (string)
        :param str key: TLS key for etcd service (string)
        :param str region: Region for S3 service (string)
        :param str signing_method: (string)
        :param str signing_name: (string)
        :param str signing_region: (string)
        :param str url: Registry URL (string)
        """
        ClusterCloudProviderAwsCloudProviderServiceOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service=service,
            key=key,
            region=region,
            signing_method=signing_method,
            signing_name=signing_name,
            signing_region=signing_region,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service: Optional[str] = None,
             key: Optional[str] = None,
             region: Optional[str] = None,
             signing_method: Optional[str] = None,
             signing_name: Optional[str] = None,
             signing_region: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if service is None:
            raise TypeError("Missing 'service' argument")
        if signing_method is None and 'signingMethod' in kwargs:
            signing_method = kwargs['signingMethod']
        if signing_name is None and 'signingName' in kwargs:
            signing_name = kwargs['signingName']
        if signing_region is None and 'signingRegion' in kwargs:
            signing_region = kwargs['signingRegion']

        _setter("service", service)
        if key is not None:
            _setter("key", key)
        if region is not None:
            _setter("region", region)
        if signing_method is not None:
            _setter("signing_method", signing_method)
        if signing_name is not None:
            _setter("signing_name", signing_name)
        if signing_region is not None:
            _setter("signing_region", signing_region)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TLS key for etcd service (string)
        """
        warnings.warn("""Use service instead""", DeprecationWarning)
        pulumi.log.warn("""key is deprecated: Use service instead""")

        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_method")

    @property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_name")

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_region")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClusterCloudProviderAzureCloudConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aadClientId":
            suggest = "aad_client_id"
        elif key == "aadClientSecret":
            suggest = "aad_client_secret"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "aadClientCertPassword":
            suggest = "aad_client_cert_password"
        elif key == "aadClientCertPath":
            suggest = "aad_client_cert_path"
        elif key == "cloudProviderBackoff":
            suggest = "cloud_provider_backoff"
        elif key == "cloudProviderBackoffDuration":
            suggest = "cloud_provider_backoff_duration"
        elif key == "cloudProviderBackoffExponent":
            suggest = "cloud_provider_backoff_exponent"
        elif key == "cloudProviderBackoffJitter":
            suggest = "cloud_provider_backoff_jitter"
        elif key == "cloudProviderBackoffRetries":
            suggest = "cloud_provider_backoff_retries"
        elif key == "cloudProviderRateLimit":
            suggest = "cloud_provider_rate_limit"
        elif key == "cloudProviderRateLimitBucket":
            suggest = "cloud_provider_rate_limit_bucket"
        elif key == "cloudProviderRateLimitQps":
            suggest = "cloud_provider_rate_limit_qps"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "maximumLoadBalancerRuleCount":
            suggest = "maximum_load_balancer_rule_count"
        elif key == "primaryAvailabilitySetName":
            suggest = "primary_availability_set_name"
        elif key == "primaryScaleSetName":
            suggest = "primary_scale_set_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "routeTableName":
            suggest = "route_table_name"
        elif key == "securityGroupName":
            suggest = "security_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "useInstanceMetadata":
            suggest = "use_instance_metadata"
        elif key == "useManagedIdentityExtension":
            suggest = "use_managed_identity_extension"
        elif key == "vmType":
            suggest = "vm_type"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "vnetResourceGroup":
            suggest = "vnet_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAzureCloudConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAzureCloudConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAzureCloudConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aad_client_id: str,
                 aad_client_secret: str,
                 subscription_id: str,
                 tenant_id: str,
                 aad_client_cert_password: Optional[str] = None,
                 aad_client_cert_path: Optional[str] = None,
                 cloud: Optional[str] = None,
                 cloud_provider_backoff: Optional[bool] = None,
                 cloud_provider_backoff_duration: Optional[int] = None,
                 cloud_provider_backoff_exponent: Optional[int] = None,
                 cloud_provider_backoff_jitter: Optional[int] = None,
                 cloud_provider_backoff_retries: Optional[int] = None,
                 cloud_provider_rate_limit: Optional[bool] = None,
                 cloud_provider_rate_limit_bucket: Optional[int] = None,
                 cloud_provider_rate_limit_qps: Optional[int] = None,
                 load_balancer_sku: Optional[str] = None,
                 location: Optional[str] = None,
                 maximum_load_balancer_rule_count: Optional[int] = None,
                 primary_availability_set_name: Optional[str] = None,
                 primary_scale_set_name: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 route_table_name: Optional[str] = None,
                 security_group_name: Optional[str] = None,
                 subnet_name: Optional[str] = None,
                 use_instance_metadata: Optional[bool] = None,
                 use_managed_identity_extension: Optional[bool] = None,
                 vm_type: Optional[str] = None,
                 vnet_name: Optional[str] = None,
                 vnet_resource_group: Optional[str] = None):
        """
        :param str aad_client_id: (string)
        :param str aad_client_secret: (string)
        :param str subscription_id: (string)
        :param str tenant_id: Required if `tenant_name` not provided. (string)
        :param str aad_client_cert_password: (string)
        :param str aad_client_cert_path: (string)
        :param str cloud: (string)
        :param bool cloud_provider_backoff: (bool)
        :param int cloud_provider_backoff_duration: (int)
        :param int cloud_provider_backoff_exponent: (int)
        :param int cloud_provider_backoff_jitter: (int)
        :param int cloud_provider_backoff_retries: (int)
        :param bool cloud_provider_rate_limit: (bool)
        :param int cloud_provider_rate_limit_bucket: (int)
        :param int cloud_provider_rate_limit_qps: (int)
        :param str location: (string)
        :param int maximum_load_balancer_rule_count: (int)
        :param str primary_availability_set_name: (string)
        :param str primary_scale_set_name: (string)
        :param str resource_group: (string)
        :param str route_table_name: (string)
        :param str security_group_name: (string)
        :param str subnet_name: (string)
        :param bool use_instance_metadata: (bool)
        :param bool use_managed_identity_extension: (bool)
        :param str vm_type: (string)
        :param str vnet_name: (string)
        :param str vnet_resource_group: (string)
        """
        ClusterCloudProviderAzureCloudConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aad_client_id=aad_client_id,
            aad_client_secret=aad_client_secret,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
            aad_client_cert_password=aad_client_cert_password,
            aad_client_cert_path=aad_client_cert_path,
            cloud=cloud,
            cloud_provider_backoff=cloud_provider_backoff,
            cloud_provider_backoff_duration=cloud_provider_backoff_duration,
            cloud_provider_backoff_exponent=cloud_provider_backoff_exponent,
            cloud_provider_backoff_jitter=cloud_provider_backoff_jitter,
            cloud_provider_backoff_retries=cloud_provider_backoff_retries,
            cloud_provider_rate_limit=cloud_provider_rate_limit,
            cloud_provider_rate_limit_bucket=cloud_provider_rate_limit_bucket,
            cloud_provider_rate_limit_qps=cloud_provider_rate_limit_qps,
            load_balancer_sku=load_balancer_sku,
            location=location,
            maximum_load_balancer_rule_count=maximum_load_balancer_rule_count,
            primary_availability_set_name=primary_availability_set_name,
            primary_scale_set_name=primary_scale_set_name,
            resource_group=resource_group,
            route_table_name=route_table_name,
            security_group_name=security_group_name,
            subnet_name=subnet_name,
            use_instance_metadata=use_instance_metadata,
            use_managed_identity_extension=use_managed_identity_extension,
            vm_type=vm_type,
            vnet_name=vnet_name,
            vnet_resource_group=vnet_resource_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aad_client_id: Optional[str] = None,
             aad_client_secret: Optional[str] = None,
             subscription_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             aad_client_cert_password: Optional[str] = None,
             aad_client_cert_path: Optional[str] = None,
             cloud: Optional[str] = None,
             cloud_provider_backoff: Optional[bool] = None,
             cloud_provider_backoff_duration: Optional[int] = None,
             cloud_provider_backoff_exponent: Optional[int] = None,
             cloud_provider_backoff_jitter: Optional[int] = None,
             cloud_provider_backoff_retries: Optional[int] = None,
             cloud_provider_rate_limit: Optional[bool] = None,
             cloud_provider_rate_limit_bucket: Optional[int] = None,
             cloud_provider_rate_limit_qps: Optional[int] = None,
             load_balancer_sku: Optional[str] = None,
             location: Optional[str] = None,
             maximum_load_balancer_rule_count: Optional[int] = None,
             primary_availability_set_name: Optional[str] = None,
             primary_scale_set_name: Optional[str] = None,
             resource_group: Optional[str] = None,
             route_table_name: Optional[str] = None,
             security_group_name: Optional[str] = None,
             subnet_name: Optional[str] = None,
             use_instance_metadata: Optional[bool] = None,
             use_managed_identity_extension: Optional[bool] = None,
             vm_type: Optional[str] = None,
             vnet_name: Optional[str] = None,
             vnet_resource_group: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aad_client_id is None and 'aadClientId' in kwargs:
            aad_client_id = kwargs['aadClientId']
        if aad_client_id is None:
            raise TypeError("Missing 'aad_client_id' argument")
        if aad_client_secret is None and 'aadClientSecret' in kwargs:
            aad_client_secret = kwargs['aadClientSecret']
        if aad_client_secret is None:
            raise TypeError("Missing 'aad_client_secret' argument")
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_id is None:
            raise TypeError("Missing 'subscription_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if aad_client_cert_password is None and 'aadClientCertPassword' in kwargs:
            aad_client_cert_password = kwargs['aadClientCertPassword']
        if aad_client_cert_path is None and 'aadClientCertPath' in kwargs:
            aad_client_cert_path = kwargs['aadClientCertPath']
        if cloud_provider_backoff is None and 'cloudProviderBackoff' in kwargs:
            cloud_provider_backoff = kwargs['cloudProviderBackoff']
        if cloud_provider_backoff_duration is None and 'cloudProviderBackoffDuration' in kwargs:
            cloud_provider_backoff_duration = kwargs['cloudProviderBackoffDuration']
        if cloud_provider_backoff_exponent is None and 'cloudProviderBackoffExponent' in kwargs:
            cloud_provider_backoff_exponent = kwargs['cloudProviderBackoffExponent']
        if cloud_provider_backoff_jitter is None and 'cloudProviderBackoffJitter' in kwargs:
            cloud_provider_backoff_jitter = kwargs['cloudProviderBackoffJitter']
        if cloud_provider_backoff_retries is None and 'cloudProviderBackoffRetries' in kwargs:
            cloud_provider_backoff_retries = kwargs['cloudProviderBackoffRetries']
        if cloud_provider_rate_limit is None and 'cloudProviderRateLimit' in kwargs:
            cloud_provider_rate_limit = kwargs['cloudProviderRateLimit']
        if cloud_provider_rate_limit_bucket is None and 'cloudProviderRateLimitBucket' in kwargs:
            cloud_provider_rate_limit_bucket = kwargs['cloudProviderRateLimitBucket']
        if cloud_provider_rate_limit_qps is None and 'cloudProviderRateLimitQps' in kwargs:
            cloud_provider_rate_limit_qps = kwargs['cloudProviderRateLimitQps']
        if load_balancer_sku is None and 'loadBalancerSku' in kwargs:
            load_balancer_sku = kwargs['loadBalancerSku']
        if maximum_load_balancer_rule_count is None and 'maximumLoadBalancerRuleCount' in kwargs:
            maximum_load_balancer_rule_count = kwargs['maximumLoadBalancerRuleCount']
        if primary_availability_set_name is None and 'primaryAvailabilitySetName' in kwargs:
            primary_availability_set_name = kwargs['primaryAvailabilitySetName']
        if primary_scale_set_name is None and 'primaryScaleSetName' in kwargs:
            primary_scale_set_name = kwargs['primaryScaleSetName']
        if resource_group is None and 'resourceGroup' in kwargs:
            resource_group = kwargs['resourceGroup']
        if route_table_name is None and 'routeTableName' in kwargs:
            route_table_name = kwargs['routeTableName']
        if security_group_name is None and 'securityGroupName' in kwargs:
            security_group_name = kwargs['securityGroupName']
        if subnet_name is None and 'subnetName' in kwargs:
            subnet_name = kwargs['subnetName']
        if use_instance_metadata is None and 'useInstanceMetadata' in kwargs:
            use_instance_metadata = kwargs['useInstanceMetadata']
        if use_managed_identity_extension is None and 'useManagedIdentityExtension' in kwargs:
            use_managed_identity_extension = kwargs['useManagedIdentityExtension']
        if vm_type is None and 'vmType' in kwargs:
            vm_type = kwargs['vmType']
        if vnet_name is None and 'vnetName' in kwargs:
            vnet_name = kwargs['vnetName']
        if vnet_resource_group is None and 'vnetResourceGroup' in kwargs:
            vnet_resource_group = kwargs['vnetResourceGroup']

        _setter("aad_client_id", aad_client_id)
        _setter("aad_client_secret", aad_client_secret)
        _setter("subscription_id", subscription_id)
        _setter("tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            _setter("aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            _setter("aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            _setter("cloud", cloud)
        if cloud_provider_backoff is not None:
            _setter("cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            _setter("cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            _setter("cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            _setter("cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            _setter("cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            _setter("cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            _setter("cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            _setter("cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            _setter("load_balancer_sku", load_balancer_sku)
        if location is not None:
            _setter("location", location)
        if maximum_load_balancer_rule_count is not None:
            _setter("maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            _setter("primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            _setter("primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            _setter("resource_group", resource_group)
        if route_table_name is not None:
            _setter("route_table_name", route_table_name)
        if security_group_name is not None:
            _setter("security_group_name", security_group_name)
        if subnet_name is not None:
            _setter("subnet_name", subnet_name)
        if use_instance_metadata is not None:
            _setter("use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            _setter("use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            _setter("vm_type", vm_type)
        if vnet_name is not None:
            _setter("vnet_name", vnet_name)
        if vnet_resource_group is not None:
            _setter("vnet_resource_group", vnet_resource_group)

    @property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_id")

    @property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_password")

    @property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_path")

    @property
    @pulumi.getter
    def cloud(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_backoff")

    @property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_rate_limit")

    @property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_availability_set_name")

    @property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_scale_set_name")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_name")

    @property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "security_group_name")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_instance_metadata")

    @property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_managed_identity_extension")

    @property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_type")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_resource_group")


@pulumi.output_type
class ClusterCloudProviderAzureCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aadClientId":
            suggest = "aad_client_id"
        elif key == "aadClientSecret":
            suggest = "aad_client_secret"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "aadClientCertPassword":
            suggest = "aad_client_cert_password"
        elif key == "aadClientCertPath":
            suggest = "aad_client_cert_path"
        elif key == "cloudProviderBackoff":
            suggest = "cloud_provider_backoff"
        elif key == "cloudProviderBackoffDuration":
            suggest = "cloud_provider_backoff_duration"
        elif key == "cloudProviderBackoffExponent":
            suggest = "cloud_provider_backoff_exponent"
        elif key == "cloudProviderBackoffJitter":
            suggest = "cloud_provider_backoff_jitter"
        elif key == "cloudProviderBackoffRetries":
            suggest = "cloud_provider_backoff_retries"
        elif key == "cloudProviderRateLimit":
            suggest = "cloud_provider_rate_limit"
        elif key == "cloudProviderRateLimitBucket":
            suggest = "cloud_provider_rate_limit_bucket"
        elif key == "cloudProviderRateLimitQps":
            suggest = "cloud_provider_rate_limit_qps"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "maximumLoadBalancerRuleCount":
            suggest = "maximum_load_balancer_rule_count"
        elif key == "primaryAvailabilitySetName":
            suggest = "primary_availability_set_name"
        elif key == "primaryScaleSetName":
            suggest = "primary_scale_set_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "routeTableName":
            suggest = "route_table_name"
        elif key == "securityGroupName":
            suggest = "security_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "useInstanceMetadata":
            suggest = "use_instance_metadata"
        elif key == "useManagedIdentityExtension":
            suggest = "use_managed_identity_extension"
        elif key == "vmType":
            suggest = "vm_type"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "vnetResourceGroup":
            suggest = "vnet_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAzureCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAzureCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAzureCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aad_client_id: str,
                 aad_client_secret: str,
                 subscription_id: str,
                 tenant_id: str,
                 aad_client_cert_password: Optional[str] = None,
                 aad_client_cert_path: Optional[str] = None,
                 cloud: Optional[str] = None,
                 cloud_provider_backoff: Optional[bool] = None,
                 cloud_provider_backoff_duration: Optional[int] = None,
                 cloud_provider_backoff_exponent: Optional[int] = None,
                 cloud_provider_backoff_jitter: Optional[int] = None,
                 cloud_provider_backoff_retries: Optional[int] = None,
                 cloud_provider_rate_limit: Optional[bool] = None,
                 cloud_provider_rate_limit_bucket: Optional[int] = None,
                 cloud_provider_rate_limit_qps: Optional[int] = None,
                 load_balancer_sku: Optional[str] = None,
                 location: Optional[str] = None,
                 maximum_load_balancer_rule_count: Optional[int] = None,
                 primary_availability_set_name: Optional[str] = None,
                 primary_scale_set_name: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 route_table_name: Optional[str] = None,
                 security_group_name: Optional[str] = None,
                 subnet_name: Optional[str] = None,
                 use_instance_metadata: Optional[bool] = None,
                 use_managed_identity_extension: Optional[bool] = None,
                 vm_type: Optional[str] = None,
                 vnet_name: Optional[str] = None,
                 vnet_resource_group: Optional[str] = None):
        """
        :param str aad_client_id: (string)
        :param str aad_client_secret: (string)
        :param str subscription_id: (string)
        :param str tenant_id: Required if `tenant_name` not provided. (string)
        :param str aad_client_cert_password: (string)
        :param str aad_client_cert_path: (string)
        :param str cloud: (string)
        :param bool cloud_provider_backoff: (bool)
        :param int cloud_provider_backoff_duration: (int)
        :param int cloud_provider_backoff_exponent: (int)
        :param int cloud_provider_backoff_jitter: (int)
        :param int cloud_provider_backoff_retries: (int)
        :param bool cloud_provider_rate_limit: (bool)
        :param int cloud_provider_rate_limit_bucket: (int)
        :param int cloud_provider_rate_limit_qps: (int)
        :param str location: (string)
        :param int maximum_load_balancer_rule_count: (int)
        :param str primary_availability_set_name: (string)
        :param str primary_scale_set_name: (string)
        :param str resource_group: (string)
        :param str route_table_name: (string)
        :param str security_group_name: (string)
        :param str subnet_name: (string)
        :param bool use_instance_metadata: (bool)
        :param bool use_managed_identity_extension: (bool)
        :param str vm_type: (string)
        :param str vnet_name: (string)
        :param str vnet_resource_group: (string)
        """
        ClusterCloudProviderAzureCloudProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aad_client_id=aad_client_id,
            aad_client_secret=aad_client_secret,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
            aad_client_cert_password=aad_client_cert_password,
            aad_client_cert_path=aad_client_cert_path,
            cloud=cloud,
            cloud_provider_backoff=cloud_provider_backoff,
            cloud_provider_backoff_duration=cloud_provider_backoff_duration,
            cloud_provider_backoff_exponent=cloud_provider_backoff_exponent,
            cloud_provider_backoff_jitter=cloud_provider_backoff_jitter,
            cloud_provider_backoff_retries=cloud_provider_backoff_retries,
            cloud_provider_rate_limit=cloud_provider_rate_limit,
            cloud_provider_rate_limit_bucket=cloud_provider_rate_limit_bucket,
            cloud_provider_rate_limit_qps=cloud_provider_rate_limit_qps,
            load_balancer_sku=load_balancer_sku,
            location=location,
            maximum_load_balancer_rule_count=maximum_load_balancer_rule_count,
            primary_availability_set_name=primary_availability_set_name,
            primary_scale_set_name=primary_scale_set_name,
            resource_group=resource_group,
            route_table_name=route_table_name,
            security_group_name=security_group_name,
            subnet_name=subnet_name,
            use_instance_metadata=use_instance_metadata,
            use_managed_identity_extension=use_managed_identity_extension,
            vm_type=vm_type,
            vnet_name=vnet_name,
            vnet_resource_group=vnet_resource_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aad_client_id: Optional[str] = None,
             aad_client_secret: Optional[str] = None,
             subscription_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             aad_client_cert_password: Optional[str] = None,
             aad_client_cert_path: Optional[str] = None,
             cloud: Optional[str] = None,
             cloud_provider_backoff: Optional[bool] = None,
             cloud_provider_backoff_duration: Optional[int] = None,
             cloud_provider_backoff_exponent: Optional[int] = None,
             cloud_provider_backoff_jitter: Optional[int] = None,
             cloud_provider_backoff_retries: Optional[int] = None,
             cloud_provider_rate_limit: Optional[bool] = None,
             cloud_provider_rate_limit_bucket: Optional[int] = None,
             cloud_provider_rate_limit_qps: Optional[int] = None,
             load_balancer_sku: Optional[str] = None,
             location: Optional[str] = None,
             maximum_load_balancer_rule_count: Optional[int] = None,
             primary_availability_set_name: Optional[str] = None,
             primary_scale_set_name: Optional[str] = None,
             resource_group: Optional[str] = None,
             route_table_name: Optional[str] = None,
             security_group_name: Optional[str] = None,
             subnet_name: Optional[str] = None,
             use_instance_metadata: Optional[bool] = None,
             use_managed_identity_extension: Optional[bool] = None,
             vm_type: Optional[str] = None,
             vnet_name: Optional[str] = None,
             vnet_resource_group: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aad_client_id is None and 'aadClientId' in kwargs:
            aad_client_id = kwargs['aadClientId']
        if aad_client_id is None:
            raise TypeError("Missing 'aad_client_id' argument")
        if aad_client_secret is None and 'aadClientSecret' in kwargs:
            aad_client_secret = kwargs['aadClientSecret']
        if aad_client_secret is None:
            raise TypeError("Missing 'aad_client_secret' argument")
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_id is None:
            raise TypeError("Missing 'subscription_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if aad_client_cert_password is None and 'aadClientCertPassword' in kwargs:
            aad_client_cert_password = kwargs['aadClientCertPassword']
        if aad_client_cert_path is None and 'aadClientCertPath' in kwargs:
            aad_client_cert_path = kwargs['aadClientCertPath']
        if cloud_provider_backoff is None and 'cloudProviderBackoff' in kwargs:
            cloud_provider_backoff = kwargs['cloudProviderBackoff']
        if cloud_provider_backoff_duration is None and 'cloudProviderBackoffDuration' in kwargs:
            cloud_provider_backoff_duration = kwargs['cloudProviderBackoffDuration']
        if cloud_provider_backoff_exponent is None and 'cloudProviderBackoffExponent' in kwargs:
            cloud_provider_backoff_exponent = kwargs['cloudProviderBackoffExponent']
        if cloud_provider_backoff_jitter is None and 'cloudProviderBackoffJitter' in kwargs:
            cloud_provider_backoff_jitter = kwargs['cloudProviderBackoffJitter']
        if cloud_provider_backoff_retries is None and 'cloudProviderBackoffRetries' in kwargs:
            cloud_provider_backoff_retries = kwargs['cloudProviderBackoffRetries']
        if cloud_provider_rate_limit is None and 'cloudProviderRateLimit' in kwargs:
            cloud_provider_rate_limit = kwargs['cloudProviderRateLimit']
        if cloud_provider_rate_limit_bucket is None and 'cloudProviderRateLimitBucket' in kwargs:
            cloud_provider_rate_limit_bucket = kwargs['cloudProviderRateLimitBucket']
        if cloud_provider_rate_limit_qps is None and 'cloudProviderRateLimitQps' in kwargs:
            cloud_provider_rate_limit_qps = kwargs['cloudProviderRateLimitQps']
        if load_balancer_sku is None and 'loadBalancerSku' in kwargs:
            load_balancer_sku = kwargs['loadBalancerSku']
        if maximum_load_balancer_rule_count is None and 'maximumLoadBalancerRuleCount' in kwargs:
            maximum_load_balancer_rule_count = kwargs['maximumLoadBalancerRuleCount']
        if primary_availability_set_name is None and 'primaryAvailabilitySetName' in kwargs:
            primary_availability_set_name = kwargs['primaryAvailabilitySetName']
        if primary_scale_set_name is None and 'primaryScaleSetName' in kwargs:
            primary_scale_set_name = kwargs['primaryScaleSetName']
        if resource_group is None and 'resourceGroup' in kwargs:
            resource_group = kwargs['resourceGroup']
        if route_table_name is None and 'routeTableName' in kwargs:
            route_table_name = kwargs['routeTableName']
        if security_group_name is None and 'securityGroupName' in kwargs:
            security_group_name = kwargs['securityGroupName']
        if subnet_name is None and 'subnetName' in kwargs:
            subnet_name = kwargs['subnetName']
        if use_instance_metadata is None and 'useInstanceMetadata' in kwargs:
            use_instance_metadata = kwargs['useInstanceMetadata']
        if use_managed_identity_extension is None and 'useManagedIdentityExtension' in kwargs:
            use_managed_identity_extension = kwargs['useManagedIdentityExtension']
        if vm_type is None and 'vmType' in kwargs:
            vm_type = kwargs['vmType']
        if vnet_name is None and 'vnetName' in kwargs:
            vnet_name = kwargs['vnetName']
        if vnet_resource_group is None and 'vnetResourceGroup' in kwargs:
            vnet_resource_group = kwargs['vnetResourceGroup']

        _setter("aad_client_id", aad_client_id)
        _setter("aad_client_secret", aad_client_secret)
        _setter("subscription_id", subscription_id)
        _setter("tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            _setter("aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            _setter("aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            _setter("cloud", cloud)
        if cloud_provider_backoff is not None:
            _setter("cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            _setter("cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            _setter("cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            _setter("cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            _setter("cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            _setter("cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            _setter("cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            _setter("cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            _setter("load_balancer_sku", load_balancer_sku)
        if location is not None:
            _setter("location", location)
        if maximum_load_balancer_rule_count is not None:
            _setter("maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            _setter("primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            _setter("primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            _setter("resource_group", resource_group)
        if route_table_name is not None:
            _setter("route_table_name", route_table_name)
        if security_group_name is not None:
            _setter("security_group_name", security_group_name)
        if subnet_name is not None:
            _setter("subnet_name", subnet_name)
        if use_instance_metadata is not None:
            _setter("use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            _setter("use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            _setter("vm_type", vm_type)
        if vnet_name is not None:
            _setter("vnet_name", vnet_name)
        if vnet_resource_group is not None:
            _setter("vnet_resource_group", vnet_resource_group)

    @property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_id")

    @property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_password")

    @property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_path")

    @property
    @pulumi.getter
    def cloud(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_backoff")

    @property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_rate_limit")

    @property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_availability_set_name")

    @property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_scale_set_name")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_name")

    @property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "security_group_name")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_instance_metadata")

    @property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_managed_identity_extension")

    @property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_type")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_resource_group")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "blockStorage":
            suggest = "block_storage"
        elif key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: 'outputs.ClusterCloudProviderOpenstackCloudConfigGlobal',
                 block_storage: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigBlockStorage'] = None,
                 load_balancer: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigLoadBalancer'] = None,
                 metadata: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigMetadata'] = None,
                 route: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigRoute'] = None):
        """
        :param 'ClusterCloudProviderOpenstackCloudConfigGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudConfigBlockStorageArgs' block_storage: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudConfigLoadBalancerArgs' load_balancer: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudConfigMetadataArgs' metadata: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudConfigRouteArgs' route: (list maxitems:1)
        """
        ClusterCloudProviderOpenstackCloudConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            global_=global_,
            block_storage=block_storage,
            load_balancer=load_balancer,
            metadata=metadata,
            route=route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             global_: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigGlobal'] = None,
             block_storage: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigBlockStorage'] = None,
             load_balancer: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigLoadBalancer'] = None,
             metadata: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigMetadata'] = None,
             route: Optional['outputs.ClusterCloudProviderOpenstackCloudConfigRoute'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']
        if global_ is None:
            raise TypeError("Missing 'global_' argument")
        if block_storage is None and 'blockStorage' in kwargs:
            block_storage = kwargs['blockStorage']
        if load_balancer is None and 'loadBalancer' in kwargs:
            load_balancer = kwargs['loadBalancer']

        _setter("global_", global_)
        if block_storage is not None:
            _setter("block_storage", block_storage)
        if load_balancer is not None:
            _setter("load_balancer", load_balancer)
        if metadata is not None:
            _setter("metadata", metadata)
        if route is not None:
            _setter("route", route)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.ClusterCloudProviderOpenstackCloudConfigGlobal':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudConfigBlockStorage']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "block_storage")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudConfigLoadBalancer']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudConfigMetadata']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def route(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudConfigRoute']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfigBlockStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bsVersion":
            suggest = "bs_version"
        elif key == "ignoreVolumeAz":
            suggest = "ignore_volume_az"
        elif key == "trustDevicePath":
            suggest = "trust_device_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfigBlockStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfigBlockStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfigBlockStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bs_version: Optional[str] = None,
                 ignore_volume_az: Optional[bool] = None,
                 trust_device_path: Optional[bool] = None):
        """
        :param str bs_version: (string)
        :param bool ignore_volume_az: (string)
        :param bool trust_device_path: (string)
        """
        ClusterCloudProviderOpenstackCloudConfigBlockStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bs_version=bs_version,
            ignore_volume_az=ignore_volume_az,
            trust_device_path=trust_device_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bs_version: Optional[str] = None,
             ignore_volume_az: Optional[bool] = None,
             trust_device_path: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bs_version is None and 'bsVersion' in kwargs:
            bs_version = kwargs['bsVersion']
        if ignore_volume_az is None and 'ignoreVolumeAz' in kwargs:
            ignore_volume_az = kwargs['ignoreVolumeAz']
        if trust_device_path is None and 'trustDevicePath' in kwargs:
            trust_device_path = kwargs['trustDevicePath']

        if bs_version is not None:
            _setter("bs_version", bs_version)
        if ignore_volume_az is not None:
            _setter("ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            _setter("trust_device_path", trust_device_path)

    @property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "bs_version")

    @property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[bool]:
        """
        (string)
        """
        return pulumi.get(self, "ignore_volume_az")

    @property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[bool]:
        """
        (string)
        """
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfigGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "caFile":
            suggest = "ca_file"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "trustId":
            suggest = "trust_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfigGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfigGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfigGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: str,
                 password: str,
                 ca_file: Optional[str] = None,
                 domain_id: Optional[str] = None,
                 domain_name: Optional[str] = None,
                 region: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 tenant_name: Optional[str] = None,
                 trust_id: Optional[str] = None,
                 user_id: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str auth_url: (string)
        :param str password: Registry password (string)
        :param str ca_file: (string)
        :param str domain_id: Required if `domain_name` not provided. (string)
        :param str domain_name: Required if `domain_id` not provided. (string)
        :param str region: Region for S3 service (string)
        :param str tenant_id: Required if `tenant_name` not provided. (string)
        :param str tenant_name: Required if `tenant_id` not provided. (string)
        :param str trust_id: (string)
        :param str user_id: Required if `username` not provided. (string)
        :param str username: Required if `user_id` not provided. (string)
        """
        ClusterCloudProviderOpenstackCloudConfigGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_url=auth_url,
            password=password,
            ca_file=ca_file,
            domain_id=domain_id,
            domain_name=domain_name,
            region=region,
            tenant_id=tenant_id,
            tenant_name=tenant_name,
            trust_id=trust_id,
            user_id=user_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_url: Optional[str] = None,
             password: Optional[str] = None,
             ca_file: Optional[str] = None,
             domain_id: Optional[str] = None,
             domain_name: Optional[str] = None,
             region: Optional[str] = None,
             tenant_id: Optional[str] = None,
             tenant_name: Optional[str] = None,
             trust_id: Optional[str] = None,
             user_id: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_url is None and 'authUrl' in kwargs:
            auth_url = kwargs['authUrl']
        if auth_url is None:
            raise TypeError("Missing 'auth_url' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if ca_file is None and 'caFile' in kwargs:
            ca_file = kwargs['caFile']
        if domain_id is None and 'domainId' in kwargs:
            domain_id = kwargs['domainId']
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_name is None and 'tenantName' in kwargs:
            tenant_name = kwargs['tenantName']
        if trust_id is None and 'trustId' in kwargs:
            trust_id = kwargs['trustId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        _setter("auth_url", auth_url)
        _setter("password", password)
        if ca_file is not None:
            _setter("ca_file", ca_file)
        if domain_id is not None:
            _setter("domain_id", domain_id)
        if domain_name is not None:
            _setter("domain_name", domain_name)
        if region is not None:
            _setter("region", region)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)
        if tenant_name is not None:
            _setter("tenant_name", tenant_name)
        if trust_id is not None:
            _setter("trust_id", trust_id)
        if user_id is not None:
            _setter("user_id", user_id)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[str]:
        """
        Required if `domain_name` not provided. (string)
        """
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Required if `domain_id` not provided. (string)
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        Required if `tenant_id` not provided. (string)
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "trust_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        Required if `username` not provided. (string)
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Required if `user_id` not provided. (string)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfigLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createMonitor":
            suggest = "create_monitor"
        elif key == "floatingNetworkId":
            suggest = "floating_network_id"
        elif key == "lbMethod":
            suggest = "lb_method"
        elif key == "lbProvider":
            suggest = "lb_provider"
        elif key == "lbVersion":
            suggest = "lb_version"
        elif key == "manageSecurityGroups":
            suggest = "manage_security_groups"
        elif key == "monitorDelay":
            suggest = "monitor_delay"
        elif key == "monitorMaxRetries":
            suggest = "monitor_max_retries"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "useOctavia":
            suggest = "use_octavia"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfigLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfigLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfigLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_monitor: Optional[bool] = None,
                 floating_network_id: Optional[str] = None,
                 lb_method: Optional[str] = None,
                 lb_provider: Optional[str] = None,
                 lb_version: Optional[str] = None,
                 manage_security_groups: Optional[bool] = None,
                 monitor_delay: Optional[str] = None,
                 monitor_max_retries: Optional[int] = None,
                 monitor_timeout: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 use_octavia: Optional[bool] = None):
        """
        :param bool create_monitor: (bool)
        :param str floating_network_id: (string)
        :param str lb_method: (string)
        :param str lb_provider: (string)
        :param str lb_version: (string)
        :param bool manage_security_groups: (bool)
        :param str monitor_delay: (string)
        :param int monitor_max_retries: (int)
        :param str monitor_timeout: (string)
        :param str subnet_id: (string)
        :param bool use_octavia: (bool)
        """
        ClusterCloudProviderOpenstackCloudConfigLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_monitor=create_monitor,
            floating_network_id=floating_network_id,
            lb_method=lb_method,
            lb_provider=lb_provider,
            lb_version=lb_version,
            manage_security_groups=manage_security_groups,
            monitor_delay=monitor_delay,
            monitor_max_retries=monitor_max_retries,
            monitor_timeout=monitor_timeout,
            subnet_id=subnet_id,
            use_octavia=use_octavia,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_monitor: Optional[bool] = None,
             floating_network_id: Optional[str] = None,
             lb_method: Optional[str] = None,
             lb_provider: Optional[str] = None,
             lb_version: Optional[str] = None,
             manage_security_groups: Optional[bool] = None,
             monitor_delay: Optional[str] = None,
             monitor_max_retries: Optional[int] = None,
             monitor_timeout: Optional[str] = None,
             subnet_id: Optional[str] = None,
             use_octavia: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_monitor is None and 'createMonitor' in kwargs:
            create_monitor = kwargs['createMonitor']
        if floating_network_id is None and 'floatingNetworkId' in kwargs:
            floating_network_id = kwargs['floatingNetworkId']
        if lb_method is None and 'lbMethod' in kwargs:
            lb_method = kwargs['lbMethod']
        if lb_provider is None and 'lbProvider' in kwargs:
            lb_provider = kwargs['lbProvider']
        if lb_version is None and 'lbVersion' in kwargs:
            lb_version = kwargs['lbVersion']
        if manage_security_groups is None and 'manageSecurityGroups' in kwargs:
            manage_security_groups = kwargs['manageSecurityGroups']
        if monitor_delay is None and 'monitorDelay' in kwargs:
            monitor_delay = kwargs['monitorDelay']
        if monitor_max_retries is None and 'monitorMaxRetries' in kwargs:
            monitor_max_retries = kwargs['monitorMaxRetries']
        if monitor_timeout is None and 'monitorTimeout' in kwargs:
            monitor_timeout = kwargs['monitorTimeout']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if use_octavia is None and 'useOctavia' in kwargs:
            use_octavia = kwargs['useOctavia']

        if create_monitor is not None:
            _setter("create_monitor", create_monitor)
        if floating_network_id is not None:
            _setter("floating_network_id", floating_network_id)
        if lb_method is not None:
            _setter("lb_method", lb_method)
        if lb_provider is not None:
            _setter("lb_provider", lb_provider)
        if lb_version is not None:
            _setter("lb_version", lb_version)
        if manage_security_groups is not None:
            _setter("manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            _setter("monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            _setter("monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            _setter("monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if use_octavia is not None:
            _setter("use_octavia", use_octavia)

    @property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "create_monitor")

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "floating_network_id")

    @property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_method")

    @property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_provider")

    @property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_version")

    @property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "manage_security_groups")

    @property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "monitor_delay")

    @property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "monitor_max_retries")

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "monitor_timeout")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfigMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "searchOrder":
            suggest = "search_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfigMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfigMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfigMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_timeout: Optional[int] = None,
                 search_order: Optional[str] = None):
        """
        :param int request_timeout: (int)
        :param str search_order: (string)
        """
        ClusterCloudProviderOpenstackCloudConfigMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_timeout=request_timeout,
            search_order=search_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_timeout: Optional[int] = None,
             search_order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if request_timeout is None and 'requestTimeout' in kwargs:
            request_timeout = kwargs['requestTimeout']
        if search_order is None and 'searchOrder' in kwargs:
            search_order = kwargs['searchOrder']

        if request_timeout is not None:
            _setter("request_timeout", request_timeout)
        if search_order is not None:
            _setter("search_order", search_order)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "search_order")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudConfigRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerId":
            suggest = "router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudConfigRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudConfigRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudConfigRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 router_id: Optional[str] = None):
        """
        :param str router_id: (string)
        """
        ClusterCloudProviderOpenstackCloudConfigRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            router_id=router_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             router_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if router_id is None and 'routerId' in kwargs:
            router_id = kwargs['routerId']

        if router_id is not None:
            _setter("router_id", router_id)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "router_id")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "blockStorage":
            suggest = "block_storage"
        elif key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: 'outputs.ClusterCloudProviderOpenstackCloudProviderGlobal',
                 block_storage: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderBlockStorage'] = None,
                 load_balancer: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderLoadBalancer'] = None,
                 metadata: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderMetadata'] = None,
                 route: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderRoute'] = None):
        """
        :param 'ClusterCloudProviderOpenstackCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudProviderBlockStorageArgs' block_storage: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudProviderLoadBalancerArgs' load_balancer: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudProviderMetadataArgs' metadata: (list maxitems:1)
        :param 'ClusterCloudProviderOpenstackCloudProviderRouteArgs' route: (list maxitems:1)
        """
        ClusterCloudProviderOpenstackCloudProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            global_=global_,
            block_storage=block_storage,
            load_balancer=load_balancer,
            metadata=metadata,
            route=route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             global_: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderGlobal'] = None,
             block_storage: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderBlockStorage'] = None,
             load_balancer: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderLoadBalancer'] = None,
             metadata: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderMetadata'] = None,
             route: Optional['outputs.ClusterCloudProviderOpenstackCloudProviderRoute'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']
        if global_ is None:
            raise TypeError("Missing 'global_' argument")
        if block_storage is None and 'blockStorage' in kwargs:
            block_storage = kwargs['blockStorage']
        if load_balancer is None and 'loadBalancer' in kwargs:
            load_balancer = kwargs['loadBalancer']

        _setter("global_", global_)
        if block_storage is not None:
            _setter("block_storage", block_storage)
        if load_balancer is not None:
            _setter("load_balancer", load_balancer)
        if metadata is not None:
            _setter("metadata", metadata)
        if route is not None:
            _setter("route", route)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.ClusterCloudProviderOpenstackCloudProviderGlobal':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudProviderBlockStorage']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "block_storage")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudProviderLoadBalancer']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudProviderMetadata']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def route(self) -> Optional['outputs.ClusterCloudProviderOpenstackCloudProviderRoute']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProviderBlockStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bsVersion":
            suggest = "bs_version"
        elif key == "ignoreVolumeAz":
            suggest = "ignore_volume_az"
        elif key == "trustDevicePath":
            suggest = "trust_device_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProviderBlockStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bs_version: Optional[str] = None,
                 ignore_volume_az: Optional[bool] = None,
                 trust_device_path: Optional[bool] = None):
        """
        :param str bs_version: (string)
        :param bool ignore_volume_az: (string)
        :param bool trust_device_path: (string)
        """
        ClusterCloudProviderOpenstackCloudProviderBlockStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bs_version=bs_version,
            ignore_volume_az=ignore_volume_az,
            trust_device_path=trust_device_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bs_version: Optional[str] = None,
             ignore_volume_az: Optional[bool] = None,
             trust_device_path: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bs_version is None and 'bsVersion' in kwargs:
            bs_version = kwargs['bsVersion']
        if ignore_volume_az is None and 'ignoreVolumeAz' in kwargs:
            ignore_volume_az = kwargs['ignoreVolumeAz']
        if trust_device_path is None and 'trustDevicePath' in kwargs:
            trust_device_path = kwargs['trustDevicePath']

        if bs_version is not None:
            _setter("bs_version", bs_version)
        if ignore_volume_az is not None:
            _setter("ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            _setter("trust_device_path", trust_device_path)

    @property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "bs_version")

    @property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[bool]:
        """
        (string)
        """
        return pulumi.get(self, "ignore_volume_az")

    @property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[bool]:
        """
        (string)
        """
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "caFile":
            suggest = "ca_file"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "trustId":
            suggest = "trust_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: str,
                 password: str,
                 ca_file: Optional[str] = None,
                 domain_id: Optional[str] = None,
                 domain_name: Optional[str] = None,
                 region: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 tenant_name: Optional[str] = None,
                 trust_id: Optional[str] = None,
                 user_id: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str auth_url: (string)
        :param str password: Registry password (string)
        :param str ca_file: (string)
        :param str domain_id: Required if `domain_name` not provided. (string)
        :param str domain_name: Required if `domain_id` not provided. (string)
        :param str region: Region for S3 service (string)
        :param str tenant_id: Required if `tenant_name` not provided. (string)
        :param str tenant_name: Required if `tenant_id` not provided. (string)
        :param str trust_id: (string)
        :param str user_id: Required if `username` not provided. (string)
        :param str username: Required if `user_id` not provided. (string)
        """
        ClusterCloudProviderOpenstackCloudProviderGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_url=auth_url,
            password=password,
            ca_file=ca_file,
            domain_id=domain_id,
            domain_name=domain_name,
            region=region,
            tenant_id=tenant_id,
            tenant_name=tenant_name,
            trust_id=trust_id,
            user_id=user_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_url: Optional[str] = None,
             password: Optional[str] = None,
             ca_file: Optional[str] = None,
             domain_id: Optional[str] = None,
             domain_name: Optional[str] = None,
             region: Optional[str] = None,
             tenant_id: Optional[str] = None,
             tenant_name: Optional[str] = None,
             trust_id: Optional[str] = None,
             user_id: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_url is None and 'authUrl' in kwargs:
            auth_url = kwargs['authUrl']
        if auth_url is None:
            raise TypeError("Missing 'auth_url' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if ca_file is None and 'caFile' in kwargs:
            ca_file = kwargs['caFile']
        if domain_id is None and 'domainId' in kwargs:
            domain_id = kwargs['domainId']
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_name is None and 'tenantName' in kwargs:
            tenant_name = kwargs['tenantName']
        if trust_id is None and 'trustId' in kwargs:
            trust_id = kwargs['trustId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        _setter("auth_url", auth_url)
        _setter("password", password)
        if ca_file is not None:
            _setter("ca_file", ca_file)
        if domain_id is not None:
            _setter("domain_id", domain_id)
        if domain_name is not None:
            _setter("domain_name", domain_name)
        if region is not None:
            _setter("region", region)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)
        if tenant_name is not None:
            _setter("tenant_name", tenant_name)
        if trust_id is not None:
            _setter("trust_id", trust_id)
        if user_id is not None:
            _setter("user_id", user_id)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[str]:
        """
        Required if `domain_name` not provided. (string)
        """
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Required if `domain_id` not provided. (string)
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        Required if `tenant_id` not provided. (string)
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "trust_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        Required if `username` not provided. (string)
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Required if `user_id` not provided. (string)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProviderLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createMonitor":
            suggest = "create_monitor"
        elif key == "floatingNetworkId":
            suggest = "floating_network_id"
        elif key == "lbMethod":
            suggest = "lb_method"
        elif key == "lbProvider":
            suggest = "lb_provider"
        elif key == "lbVersion":
            suggest = "lb_version"
        elif key == "manageSecurityGroups":
            suggest = "manage_security_groups"
        elif key == "monitorDelay":
            suggest = "monitor_delay"
        elif key == "monitorMaxRetries":
            suggest = "monitor_max_retries"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "useOctavia":
            suggest = "use_octavia"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProviderLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_monitor: Optional[bool] = None,
                 floating_network_id: Optional[str] = None,
                 lb_method: Optional[str] = None,
                 lb_provider: Optional[str] = None,
                 lb_version: Optional[str] = None,
                 manage_security_groups: Optional[bool] = None,
                 monitor_delay: Optional[str] = None,
                 monitor_max_retries: Optional[int] = None,
                 monitor_timeout: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 use_octavia: Optional[bool] = None):
        """
        :param bool create_monitor: (bool)
        :param str floating_network_id: (string)
        :param str lb_method: (string)
        :param str lb_provider: (string)
        :param str lb_version: (string)
        :param bool manage_security_groups: (bool)
        :param str monitor_delay: (string)
        :param int monitor_max_retries: (int)
        :param str monitor_timeout: (string)
        :param str subnet_id: (string)
        :param bool use_octavia: (bool)
        """
        ClusterCloudProviderOpenstackCloudProviderLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_monitor=create_monitor,
            floating_network_id=floating_network_id,
            lb_method=lb_method,
            lb_provider=lb_provider,
            lb_version=lb_version,
            manage_security_groups=manage_security_groups,
            monitor_delay=monitor_delay,
            monitor_max_retries=monitor_max_retries,
            monitor_timeout=monitor_timeout,
            subnet_id=subnet_id,
            use_octavia=use_octavia,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_monitor: Optional[bool] = None,
             floating_network_id: Optional[str] = None,
             lb_method: Optional[str] = None,
             lb_provider: Optional[str] = None,
             lb_version: Optional[str] = None,
             manage_security_groups: Optional[bool] = None,
             monitor_delay: Optional[str] = None,
             monitor_max_retries: Optional[int] = None,
             monitor_timeout: Optional[str] = None,
             subnet_id: Optional[str] = None,
             use_octavia: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_monitor is None and 'createMonitor' in kwargs:
            create_monitor = kwargs['createMonitor']
        if floating_network_id is None and 'floatingNetworkId' in kwargs:
            floating_network_id = kwargs['floatingNetworkId']
        if lb_method is None and 'lbMethod' in kwargs:
            lb_method = kwargs['lbMethod']
        if lb_provider is None and 'lbProvider' in kwargs:
            lb_provider = kwargs['lbProvider']
        if lb_version is None and 'lbVersion' in kwargs:
            lb_version = kwargs['lbVersion']
        if manage_security_groups is None and 'manageSecurityGroups' in kwargs:
            manage_security_groups = kwargs['manageSecurityGroups']
        if monitor_delay is None and 'monitorDelay' in kwargs:
            monitor_delay = kwargs['monitorDelay']
        if monitor_max_retries is None and 'monitorMaxRetries' in kwargs:
            monitor_max_retries = kwargs['monitorMaxRetries']
        if monitor_timeout is None and 'monitorTimeout' in kwargs:
            monitor_timeout = kwargs['monitorTimeout']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if use_octavia is None and 'useOctavia' in kwargs:
            use_octavia = kwargs['useOctavia']

        if create_monitor is not None:
            _setter("create_monitor", create_monitor)
        if floating_network_id is not None:
            _setter("floating_network_id", floating_network_id)
        if lb_method is not None:
            _setter("lb_method", lb_method)
        if lb_provider is not None:
            _setter("lb_provider", lb_provider)
        if lb_version is not None:
            _setter("lb_version", lb_version)
        if manage_security_groups is not None:
            _setter("manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            _setter("monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            _setter("monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            _setter("monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if use_octavia is not None:
            _setter("use_octavia", use_octavia)

    @property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "create_monitor")

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "floating_network_id")

    @property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_method")

    @property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_provider")

    @property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_version")

    @property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "manage_security_groups")

    @property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "monitor_delay")

    @property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "monitor_max_retries")

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "monitor_timeout")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProviderMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "searchOrder":
            suggest = "search_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProviderMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_timeout: Optional[int] = None,
                 search_order: Optional[str] = None):
        """
        :param int request_timeout: (int)
        :param str search_order: (string)
        """
        ClusterCloudProviderOpenstackCloudProviderMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_timeout=request_timeout,
            search_order=search_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_timeout: Optional[int] = None,
             search_order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if request_timeout is None and 'requestTimeout' in kwargs:
            request_timeout = kwargs['requestTimeout']
        if search_order is None and 'searchOrder' in kwargs:
            search_order = kwargs['searchOrder']

        if request_timeout is not None:
            _setter("request_timeout", request_timeout)
        if search_order is not None:
            _setter("search_order", search_order)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "search_order")


@pulumi.output_type
class ClusterCloudProviderOpenstackCloudProviderRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerId":
            suggest = "router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackCloudProviderRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 router_id: Optional[str] = None):
        """
        :param str router_id: (string)
        """
        ClusterCloudProviderOpenstackCloudProviderRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            router_id=router_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             router_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if router_id is None and 'routerId' in kwargs:
            router_id = kwargs['routerId']

        if router_id is not None:
            _setter("router_id", router_id)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "router_id")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualCenters":
            suggest = "virtual_centers"
        elif key == "global":
            suggest = "global_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_centers: Sequence['outputs.ClusterCloudProviderVsphereCloudConfigVirtualCenter'],
                 workspace: 'outputs.ClusterCloudProviderVsphereCloudConfigWorkspace',
                 disk: Optional['outputs.ClusterCloudProviderVsphereCloudConfigDisk'] = None,
                 global_: Optional['outputs.ClusterCloudProviderVsphereCloudConfigGlobal'] = None,
                 network: Optional['outputs.ClusterCloudProviderVsphereCloudConfigNetwork'] = None):
        """
        :param Sequence['ClusterCloudProviderVsphereCloudConfigVirtualCenterArgs'] virtual_centers: (List)
        :param 'ClusterCloudProviderVsphereCloudConfigWorkspaceArgs' workspace: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudConfigDiskArgs' disk: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudConfigGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudConfigNetworkArgs' network: RKE k8s cluster network configuration (list maxitems:1)
        """
        ClusterCloudProviderVsphereCloudConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_centers=virtual_centers,
            workspace=workspace,
            disk=disk,
            global_=global_,
            network=network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_centers: Optional[Sequence['outputs.ClusterCloudProviderVsphereCloudConfigVirtualCenter']] = None,
             workspace: Optional['outputs.ClusterCloudProviderVsphereCloudConfigWorkspace'] = None,
             disk: Optional['outputs.ClusterCloudProviderVsphereCloudConfigDisk'] = None,
             global_: Optional['outputs.ClusterCloudProviderVsphereCloudConfigGlobal'] = None,
             network: Optional['outputs.ClusterCloudProviderVsphereCloudConfigNetwork'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_centers is None and 'virtualCenters' in kwargs:
            virtual_centers = kwargs['virtualCenters']
        if virtual_centers is None:
            raise TypeError("Missing 'virtual_centers' argument")
        if workspace is None:
            raise TypeError("Missing 'workspace' argument")
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']

        _setter("virtual_centers", virtual_centers)
        _setter("workspace", workspace)
        if disk is not None:
            _setter("disk", disk)
        if global_ is not None:
            _setter("global_", global_)
        if network is not None:
            _setter("network", network)

    @property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.ClusterCloudProviderVsphereCloudConfigVirtualCenter']:
        """
        (List)
        """
        return pulumi.get(self, "virtual_centers")

    @property
    @pulumi.getter
    def workspace(self) -> 'outputs.ClusterCloudProviderVsphereCloudConfigWorkspace':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "workspace")

    @property
    @pulumi.getter
    def disk(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudConfigDisk']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudConfigGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudConfigNetwork']:
        """
        RKE k8s cluster network configuration (list maxitems:1)
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfigDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scsiControllerType":
            suggest = "scsi_controller_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfigDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfigDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfigDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scsi_controller_type: Optional[str] = None):
        """
        :param str scsi_controller_type: (string)
        """
        ClusterCloudProviderVsphereCloudConfigDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scsi_controller_type=scsi_controller_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scsi_controller_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scsi_controller_type is None and 'scsiControllerType' in kwargs:
            scsi_controller_type = kwargs['scsiControllerType']

        if scsi_controller_type is not None:
            _setter("scsi_controller_type", scsi_controller_type)

    @property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfigGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insecureFlag":
            suggest = "insecure_flag"
        elif key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"
        elif key == "vmName":
            suggest = "vm_name"
        elif key == "vmUuid":
            suggest = "vm_uuid"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfigGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfigGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfigGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: Optional[str] = None,
                 datacenters: Optional[str] = None,
                 datastore: Optional[str] = None,
                 insecure_flag: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 soap_roundtrip_count: Optional[int] = None,
                 user: Optional[str] = None,
                 vm_name: Optional[str] = None,
                 vm_uuid: Optional[str] = None,
                 working_dir: Optional[str] = None):
        """
        :param str datacenter: (string)
        :param str datacenters: (string)
        :param str datastore: (string)
        :param bool insecure_flag: (bool)
        :param str password: Registry password (string)
        :param str port: Port used for SSH communication (string)
        :param int soap_roundtrip_count: (int)
        :param str user: Registry user (string)
        :param str vm_name: (string)
        :param str vm_uuid: (string)
        :param str working_dir: (string)
        """
        ClusterCloudProviderVsphereCloudConfigGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenter=datacenter,
            datacenters=datacenters,
            datastore=datastore,
            insecure_flag=insecure_flag,
            password=password,
            port=port,
            soap_roundtrip_count=soap_roundtrip_count,
            user=user,
            vm_name=vm_name,
            vm_uuid=vm_uuid,
            working_dir=working_dir,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenter: Optional[str] = None,
             datacenters: Optional[str] = None,
             datastore: Optional[str] = None,
             insecure_flag: Optional[bool] = None,
             password: Optional[str] = None,
             port: Optional[str] = None,
             soap_roundtrip_count: Optional[int] = None,
             user: Optional[str] = None,
             vm_name: Optional[str] = None,
             vm_uuid: Optional[str] = None,
             working_dir: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insecure_flag is None and 'insecureFlag' in kwargs:
            insecure_flag = kwargs['insecureFlag']
        if soap_roundtrip_count is None and 'soapRoundtripCount' in kwargs:
            soap_roundtrip_count = kwargs['soapRoundtripCount']
        if vm_name is None and 'vmName' in kwargs:
            vm_name = kwargs['vmName']
        if vm_uuid is None and 'vmUuid' in kwargs:
            vm_uuid = kwargs['vmUuid']
        if working_dir is None and 'workingDir' in kwargs:
            working_dir = kwargs['workingDir']

        if datacenter is not None:
            _setter("datacenter", datacenter)
        if datacenters is not None:
            _setter("datacenters", datacenters)
        if datastore is not None:
            _setter("datastore", datastore)
        if insecure_flag is not None:
            _setter("insecure_flag", insecure_flag)
        if password is not None:
            _setter("password", password)
        if port is not None:
            _setter("port", port)
        if soap_roundtrip_count is not None:
            _setter("soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            _setter("user", user)
        if vm_name is not None:
            _setter("vm_name", vm_name)
        if vm_uuid is not None:
            _setter("vm_uuid", vm_uuid)
        if working_dir is not None:
            _setter("working_dir", working_dir)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @property
    @pulumi.getter
    def datastore(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "insecure_flag")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_name")

    @property
    @pulumi.getter(name="vmUuid")
    def vm_uuid(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_uuid")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfigNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicNetwork":
            suggest = "public_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfigNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfigNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfigNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_network: Optional[str] = None):
        """
        :param str public_network: (string)
        """
        ClusterCloudProviderVsphereCloudConfigNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_network=public_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_network is None and 'publicNetwork' in kwargs:
            public_network = kwargs['publicNetwork']

        if public_network is not None:
            _setter("public_network", public_network)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "public_network")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfigVirtualCenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfigVirtualCenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfigVirtualCenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfigVirtualCenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: str,
                 name: str,
                 password: str,
                 user: str,
                 port: Optional[str] = None,
                 soap_roundtrip_count: Optional[int] = None):
        """
        :param str datacenters: (string)
        :param str name: Name of virtualcenter config for Vsphere Cloud Provider config (string)
        :param str password: Registry password (string)
        :param str user: Registry user (string)
        :param str port: Port used for SSH communication (string)
        :param int soap_roundtrip_count: (int)
        """
        ClusterCloudProviderVsphereCloudConfigVirtualCenter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenters=datacenters,
            name=name,
            password=password,
            user=user,
            port=port,
            soap_roundtrip_count=soap_roundtrip_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenters: Optional[str] = None,
             name: Optional[str] = None,
             password: Optional[str] = None,
             user: Optional[str] = None,
             port: Optional[str] = None,
             soap_roundtrip_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datacenters is None:
            raise TypeError("Missing 'datacenters' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")
        if soap_roundtrip_count is None and 'soapRoundtripCount' in kwargs:
            soap_roundtrip_count = kwargs['soapRoundtripCount']

        _setter("datacenters", datacenters)
        _setter("name", name)
        _setter("password", password)
        _setter("user", user)
        if port is not None:
            _setter("port", port)
        if soap_roundtrip_count is not None:
            _setter("soap_roundtrip_count", soap_roundtrip_count)

    @property
    @pulumi.getter
    def datacenters(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of virtualcenter config for Vsphere Cloud Provider config (string)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudConfigWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDatastore":
            suggest = "default_datastore"
        elif key == "resourcepoolPath":
            suggest = "resourcepool_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudConfigWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudConfigWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudConfigWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: str,
                 server: str,
                 default_datastore: Optional[str] = None,
                 folder: Optional[str] = None,
                 resourcepool_path: Optional[str] = None):
        """
        :param str datacenter: (string)
        :param str server: (string)
        :param str default_datastore: (string)
        :param str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param str resourcepool_path: (string)
        """
        ClusterCloudProviderVsphereCloudConfigWorkspace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenter=datacenter,
            server=server,
            default_datastore=default_datastore,
            folder=folder,
            resourcepool_path=resourcepool_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenter: Optional[str] = None,
             server: Optional[str] = None,
             default_datastore: Optional[str] = None,
             folder: Optional[str] = None,
             resourcepool_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datacenter is None:
            raise TypeError("Missing 'datacenter' argument")
        if server is None:
            raise TypeError("Missing 'server' argument")
        if default_datastore is None and 'defaultDatastore' in kwargs:
            default_datastore = kwargs['defaultDatastore']
        if resourcepool_path is None and 'resourcepoolPath' in kwargs:
            resourcepool_path = kwargs['resourcepoolPath']

        _setter("datacenter", datacenter)
        _setter("server", server)
        if default_datastore is not None:
            _setter("default_datastore", default_datastore)
        if folder is not None:
            _setter("folder", folder)
        if resourcepool_path is not None:
            _setter("resourcepool_path", resourcepool_path)

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "default_datastore")

    @property
    @pulumi.getter
    def folder(self) -> Optional[str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "resourcepool_path")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualCenters":
            suggest = "virtual_centers"
        elif key == "global":
            suggest = "global_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_centers: Sequence['outputs.ClusterCloudProviderVsphereCloudProviderVirtualCenter'],
                 workspace: 'outputs.ClusterCloudProviderVsphereCloudProviderWorkspace',
                 disk: Optional['outputs.ClusterCloudProviderVsphereCloudProviderDisk'] = None,
                 global_: Optional['outputs.ClusterCloudProviderVsphereCloudProviderGlobal'] = None,
                 network: Optional['outputs.ClusterCloudProviderVsphereCloudProviderNetwork'] = None):
        """
        :param Sequence['ClusterCloudProviderVsphereCloudProviderVirtualCenterArgs'] virtual_centers: (List)
        :param 'ClusterCloudProviderVsphereCloudProviderWorkspaceArgs' workspace: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudProviderDiskArgs' disk: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterCloudProviderVsphereCloudProviderNetworkArgs' network: RKE k8s cluster network configuration (list maxitems:1)
        """
        ClusterCloudProviderVsphereCloudProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            virtual_centers=virtual_centers,
            workspace=workspace,
            disk=disk,
            global_=global_,
            network=network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             virtual_centers: Optional[Sequence['outputs.ClusterCloudProviderVsphereCloudProviderVirtualCenter']] = None,
             workspace: Optional['outputs.ClusterCloudProviderVsphereCloudProviderWorkspace'] = None,
             disk: Optional['outputs.ClusterCloudProviderVsphereCloudProviderDisk'] = None,
             global_: Optional['outputs.ClusterCloudProviderVsphereCloudProviderGlobal'] = None,
             network: Optional['outputs.ClusterCloudProviderVsphereCloudProviderNetwork'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if virtual_centers is None and 'virtualCenters' in kwargs:
            virtual_centers = kwargs['virtualCenters']
        if virtual_centers is None:
            raise TypeError("Missing 'virtual_centers' argument")
        if workspace is None:
            raise TypeError("Missing 'workspace' argument")
        if global_ is None and 'global' in kwargs:
            global_ = kwargs['global']

        _setter("virtual_centers", virtual_centers)
        _setter("workspace", workspace)
        if disk is not None:
            _setter("disk", disk)
        if global_ is not None:
            _setter("global_", global_)
        if network is not None:
            _setter("network", network)

    @property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.ClusterCloudProviderVsphereCloudProviderVirtualCenter']:
        """
        (List)
        """
        return pulumi.get(self, "virtual_centers")

    @property
    @pulumi.getter
    def workspace(self) -> 'outputs.ClusterCloudProviderVsphereCloudProviderWorkspace':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "workspace")

    @property
    @pulumi.getter
    def disk(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudProviderDisk']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudProviderGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterCloudProviderVsphereCloudProviderNetwork']:
        """
        RKE k8s cluster network configuration (list maxitems:1)
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProviderDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scsiControllerType":
            suggest = "scsi_controller_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProviderDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scsi_controller_type: Optional[str] = None):
        """
        :param str scsi_controller_type: (string)
        """
        ClusterCloudProviderVsphereCloudProviderDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scsi_controller_type=scsi_controller_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scsi_controller_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scsi_controller_type is None and 'scsiControllerType' in kwargs:
            scsi_controller_type = kwargs['scsiControllerType']

        if scsi_controller_type is not None:
            _setter("scsi_controller_type", scsi_controller_type)

    @property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insecureFlag":
            suggest = "insecure_flag"
        elif key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"
        elif key == "vmName":
            suggest = "vm_name"
        elif key == "vmUuid":
            suggest = "vm_uuid"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: Optional[str] = None,
                 datacenters: Optional[str] = None,
                 datastore: Optional[str] = None,
                 insecure_flag: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[str] = None,
                 soap_roundtrip_count: Optional[int] = None,
                 user: Optional[str] = None,
                 vm_name: Optional[str] = None,
                 vm_uuid: Optional[str] = None,
                 working_dir: Optional[str] = None):
        """
        :param str datacenter: (string)
        :param str datacenters: (string)
        :param str datastore: (string)
        :param bool insecure_flag: (bool)
        :param str password: Registry password (string)
        :param str port: Port used for SSH communication (string)
        :param int soap_roundtrip_count: (int)
        :param str user: Registry user (string)
        :param str vm_name: (string)
        :param str vm_uuid: (string)
        :param str working_dir: (string)
        """
        ClusterCloudProviderVsphereCloudProviderGlobal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenter=datacenter,
            datacenters=datacenters,
            datastore=datastore,
            insecure_flag=insecure_flag,
            password=password,
            port=port,
            soap_roundtrip_count=soap_roundtrip_count,
            user=user,
            vm_name=vm_name,
            vm_uuid=vm_uuid,
            working_dir=working_dir,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenter: Optional[str] = None,
             datacenters: Optional[str] = None,
             datastore: Optional[str] = None,
             insecure_flag: Optional[bool] = None,
             password: Optional[str] = None,
             port: Optional[str] = None,
             soap_roundtrip_count: Optional[int] = None,
             user: Optional[str] = None,
             vm_name: Optional[str] = None,
             vm_uuid: Optional[str] = None,
             working_dir: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insecure_flag is None and 'insecureFlag' in kwargs:
            insecure_flag = kwargs['insecureFlag']
        if soap_roundtrip_count is None and 'soapRoundtripCount' in kwargs:
            soap_roundtrip_count = kwargs['soapRoundtripCount']
        if vm_name is None and 'vmName' in kwargs:
            vm_name = kwargs['vmName']
        if vm_uuid is None and 'vmUuid' in kwargs:
            vm_uuid = kwargs['vmUuid']
        if working_dir is None and 'workingDir' in kwargs:
            working_dir = kwargs['workingDir']

        if datacenter is not None:
            _setter("datacenter", datacenter)
        if datacenters is not None:
            _setter("datacenters", datacenters)
        if datastore is not None:
            _setter("datastore", datastore)
        if insecure_flag is not None:
            _setter("insecure_flag", insecure_flag)
        if password is not None:
            _setter("password", password)
        if port is not None:
            _setter("port", port)
        if soap_roundtrip_count is not None:
            _setter("soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            _setter("user", user)
        if vm_name is not None:
            _setter("vm_name", vm_name)
        if vm_uuid is not None:
            _setter("vm_uuid", vm_uuid)
        if working_dir is not None:
            _setter("working_dir", working_dir)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @property
    @pulumi.getter
    def datastore(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[bool]:
        """
        (bool)
        """
        return pulumi.get(self, "insecure_flag")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_name")

    @property
    @pulumi.getter(name="vmUuid")
    def vm_uuid(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_uuid")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProviderNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicNetwork":
            suggest = "public_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProviderNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_network: Optional[str] = None):
        """
        :param str public_network: (string)
        """
        ClusterCloudProviderVsphereCloudProviderNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_network=public_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_network is None and 'publicNetwork' in kwargs:
            public_network = kwargs['publicNetwork']

        if public_network is not None:
            _setter("public_network", public_network)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "public_network")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProviderVirtualCenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProviderVirtualCenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: str,
                 name: str,
                 password: str,
                 user: str,
                 port: Optional[str] = None,
                 soap_roundtrip_count: Optional[int] = None):
        """
        :param str datacenters: (string)
        :param str name: Name of virtualcenter config for Vsphere Cloud Provider config (string)
        :param str password: Registry password (string)
        :param str user: Registry user (string)
        :param str port: Port used for SSH communication (string)
        :param int soap_roundtrip_count: (int)
        """
        ClusterCloudProviderVsphereCloudProviderVirtualCenter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenters=datacenters,
            name=name,
            password=password,
            user=user,
            port=port,
            soap_roundtrip_count=soap_roundtrip_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenters: Optional[str] = None,
             name: Optional[str] = None,
             password: Optional[str] = None,
             user: Optional[str] = None,
             port: Optional[str] = None,
             soap_roundtrip_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datacenters is None:
            raise TypeError("Missing 'datacenters' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")
        if soap_roundtrip_count is None and 'soapRoundtripCount' in kwargs:
            soap_roundtrip_count = kwargs['soapRoundtripCount']

        _setter("datacenters", datacenters)
        _setter("name", name)
        _setter("password", password)
        _setter("user", user)
        if port is not None:
            _setter("port", port)
        if soap_roundtrip_count is not None:
            _setter("soap_roundtrip_count", soap_roundtrip_count)

    @property
    @pulumi.getter
    def datacenters(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of virtualcenter config for Vsphere Cloud Provider config (string)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")


@pulumi.output_type
class ClusterCloudProviderVsphereCloudProviderWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDatastore":
            suggest = "default_datastore"
        elif key == "resourcepoolPath":
            suggest = "resourcepool_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderVsphereCloudProviderWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: str,
                 server: str,
                 default_datastore: Optional[str] = None,
                 folder: Optional[str] = None,
                 resourcepool_path: Optional[str] = None):
        """
        :param str datacenter: (string)
        :param str server: (string)
        :param str default_datastore: (string)
        :param str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param str resourcepool_path: (string)
        """
        ClusterCloudProviderVsphereCloudProviderWorkspace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenter=datacenter,
            server=server,
            default_datastore=default_datastore,
            folder=folder,
            resourcepool_path=resourcepool_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenter: Optional[str] = None,
             server: Optional[str] = None,
             default_datastore: Optional[str] = None,
             folder: Optional[str] = None,
             resourcepool_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datacenter is None:
            raise TypeError("Missing 'datacenter' argument")
        if server is None:
            raise TypeError("Missing 'server' argument")
        if default_datastore is None and 'defaultDatastore' in kwargs:
            default_datastore = kwargs['defaultDatastore']
        if resourcepool_path is None and 'resourcepoolPath' in kwargs:
            resourcepool_path = kwargs['resourcepoolPath']

        _setter("datacenter", datacenter)
        _setter("server", server)
        if default_datastore is not None:
            _setter("default_datastore", default_datastore)
        if folder is not None:
            _setter("folder", folder)
        if resourcepool_path is not None:
            _setter("resourcepool_path", resourcepool_path)

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "default_datastore")

    @property
    @pulumi.getter
    def folder(self) -> Optional[str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[str]:
        """
        (string)
        """
        return pulumi.get(self, "resourcepool_path")


@pulumi.output_type
class ClusterControlPlaneHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterControlPlaneHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterControlPlaneHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterControlPlaneHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 node_name: Optional[str] = None):
        """
        :param str address: Address ip for node (string)
        :param str node_name: Name of the host provisioned via docker machine (string)
        """
        ClusterControlPlaneHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            node_name=node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']

        if address is not None:
            _setter("address", address)
        if node_name is not None:
            _setter("node_name", node_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the host provisioned via docker machine (string)
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class ClusterDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelector":
            suggest = "node_selector"
        elif key == "reverseCidrs":
            suggest = "reverse_cidrs"
        elif key == "upstreamNameservers":
            suggest = "upstream_nameservers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector: Optional[Mapping[str, Any]] = None,
                 nodelocal: Optional['outputs.ClusterDnsNodelocal'] = None,
                 provider: Optional[str] = None,
                 reverse_cidrs: Optional[Sequence[str]] = None,
                 upstream_nameservers: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, Any] node_selector: Node selector key pair (map)
        :param 'ClusterDnsNodelocalArgs' nodelocal: Docker image for nodelocal (string)
        :param str provider: Monitoring provider (string)
        :param Sequence[str] reverse_cidrs: Reverse CIDRs  (list)
        :param Sequence[str] upstream_nameservers: Upstream nameservers  (list)
        """
        ClusterDns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_selector=node_selector,
            nodelocal=nodelocal,
            provider=provider,
            reverse_cidrs=reverse_cidrs,
            upstream_nameservers=upstream_nameservers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_selector: Optional[Mapping[str, Any]] = None,
             nodelocal: Optional['outputs.ClusterDnsNodelocal'] = None,
             provider: Optional[str] = None,
             reverse_cidrs: Optional[Sequence[str]] = None,
             upstream_nameservers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_selector is None and 'nodeSelector' in kwargs:
            node_selector = kwargs['nodeSelector']
        if reverse_cidrs is None and 'reverseCidrs' in kwargs:
            reverse_cidrs = kwargs['reverseCidrs']
        if upstream_nameservers is None and 'upstreamNameservers' in kwargs:
            upstream_nameservers = kwargs['upstreamNameservers']

        if node_selector is not None:
            _setter("node_selector", node_selector)
        if nodelocal is not None:
            _setter("nodelocal", nodelocal)
        if provider is not None:
            _setter("provider", provider)
        if reverse_cidrs is not None:
            _setter("reverse_cidrs", reverse_cidrs)
        if upstream_nameservers is not None:
            _setter("upstream_nameservers", upstream_nameservers)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, Any]]:
        """
        Node selector key pair (map)
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter
    def nodelocal(self) -> Optional['outputs.ClusterDnsNodelocal']:
        """
        Docker image for nodelocal (string)
        """
        return pulumi.get(self, "nodelocal")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Optional[Sequence[str]]:
        """
        Reverse CIDRs  (list)
        """
        return pulumi.get(self, "reverse_cidrs")

    @property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[Sequence[str]]:
        """
        Upstream nameservers  (list)
        """
        return pulumi.get(self, "upstream_nameservers")


@pulumi.output_type
class ClusterDnsNodelocal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDnsNodelocal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDnsNodelocal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDnsNodelocal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[str] = None,
                 node_selector: Optional[Mapping[str, Any]] = None):
        """
        :param str ip_address: Nodelocal dns ip address (string)
        :param Mapping[str, Any] node_selector: Node selector key pair (map)
        """
        ClusterDnsNodelocal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_address=ip_address,
            node_selector=node_selector,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_address: Optional[str] = None,
             node_selector: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if node_selector is None and 'nodeSelector' in kwargs:
            node_selector = kwargs['nodeSelector']

        if ip_address is not None:
            _setter("ip_address", ip_address)
        if node_selector is not None:
            _setter("node_selector", node_selector)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Nodelocal dns ip address (string)
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, Any]]:
        """
        Node selector key pair (map)
        """
        return pulumi.get(self, "node_selector")


@pulumi.output_type
class ClusterEtcdHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEtcdHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEtcdHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEtcdHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 node_name: Optional[str] = None):
        """
        :param str address: Address ip for node (string)
        :param str node_name: Name of the host provisioned via docker machine (string)
        """
        ClusterEtcdHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            node_name=node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']

        if address is not None:
            _setter("address", address)
        if node_name is not None:
            _setter("node_name", node_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the host provisioned via docker machine (string)
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class ClusterInactiveHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInactiveHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInactiveHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInactiveHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 node_name: Optional[str] = None):
        """
        :param str address: Address ip for node (string)
        :param str node_name: Name of the host provisioned via docker machine (string)
        """
        ClusterInactiveHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            node_name=node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']

        if address is not None:
            _setter("address", address)
        if node_name is not None:
            _setter("node_name", node_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the host provisioned via docker machine (string)
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class ClusterIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBackend":
            suggest = "default_backend"
        elif key == "dnsPolicy":
            suggest = "dns_policy"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_backend: Optional[bool] = None,
                 dns_policy: Optional[str] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 network_mode: Optional[str] = None,
                 node_selector: Optional[Mapping[str, Any]] = None,
                 options: Optional[Mapping[str, Any]] = None,
                 provider: Optional[str] = None):
        """
        :param str dns_policy: Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param int http_port: Ingress controller http port (int)
        :param int https_port: Ingress controller https port (int)
        :param str network_mode: Networt mode for the ingress controller. `hostNetwork`, `hostPort` and `none` are supported (string)
        :param Mapping[str, Any] node_selector: Node selector key pair (map)
        :param Mapping[str, Any] options: Network provider options (map)
        :param str provider: Monitoring provider (string)
        """
        ClusterIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_backend=default_backend,
            dns_policy=dns_policy,
            extra_args=extra_args,
            http_port=http_port,
            https_port=https_port,
            network_mode=network_mode,
            node_selector=node_selector,
            options=options,
            provider=provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_backend: Optional[bool] = None,
             dns_policy: Optional[str] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             http_port: Optional[int] = None,
             https_port: Optional[int] = None,
             network_mode: Optional[str] = None,
             node_selector: Optional[Mapping[str, Any]] = None,
             options: Optional[Mapping[str, Any]] = None,
             provider: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_backend is None and 'defaultBackend' in kwargs:
            default_backend = kwargs['defaultBackend']
        if dns_policy is None and 'dnsPolicy' in kwargs:
            dns_policy = kwargs['dnsPolicy']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if http_port is None and 'httpPort' in kwargs:
            http_port = kwargs['httpPort']
        if https_port is None and 'httpsPort' in kwargs:
            https_port = kwargs['httpsPort']
        if network_mode is None and 'networkMode' in kwargs:
            network_mode = kwargs['networkMode']
        if node_selector is None and 'nodeSelector' in kwargs:
            node_selector = kwargs['nodeSelector']

        if default_backend is not None:
            _setter("default_backend", default_backend)
        if dns_policy is not None:
            _setter("dns_policy", dns_policy)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if http_port is not None:
            _setter("http_port", http_port)
        if https_port is not None:
            _setter("https_port", https_port)
        if network_mode is not None:
            _setter("network_mode", network_mode)
        if node_selector is not None:
            _setter("node_selector", node_selector)
        if options is not None:
            _setter("options", options)
        if provider is not None:
            _setter("provider", provider)

    @property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[bool]:
        return pulumi.get(self, "default_backend")

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[str]:
        """
        Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        """
        return pulumi.get(self, "dns_policy")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        Ingress controller http port (int)
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        Ingress controller https port (int)
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[str]:
        """
        Networt mode for the ingress controller. `hostNetwork`, `hostPort` and `none` are supported (string)
        """
        return pulumi.get(self, "network_mode")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, Any]]:
        """
        Node selector key pair (map)
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Network provider options (map)
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Monitoring provider (string)
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class ClusterMonitoring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMonitoring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMonitoring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMonitoring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector: Optional[Mapping[str, Any]] = None,
                 options: Optional[Mapping[str, Any]] = None,
                 provider: Optional[str] = None):
        """
        :param Mapping[str, Any] node_selector: Node selector key pair (map)
        :param Mapping[str, Any] options: Network provider options (map)
        :param str provider: Monitoring provider (string)
        """
        ClusterMonitoring._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_selector=node_selector,
            options=options,
            provider=provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_selector: Optional[Mapping[str, Any]] = None,
             options: Optional[Mapping[str, Any]] = None,
             provider: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_selector is None and 'nodeSelector' in kwargs:
            node_selector = kwargs['nodeSelector']

        if node_selector is not None:
            _setter("node_selector", node_selector)
        if options is not None:
            _setter("options", options)
        if provider is not None:
            _setter("provider", provider)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, Any]]:
        """
        Node selector key pair (map)
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Network provider options (map)
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Monitoring provider (string)
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class ClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciNetworkProvider":
            suggest = "aci_network_provider"
        elif key == "calicoNetworkProvider":
            suggest = "calico_network_provider"
        elif key == "canalNetworkProvider":
            suggest = "canal_network_provider"
        elif key == "flannelNetworkProvider":
            suggest = "flannel_network_provider"
        elif key == "weaveNetworkProvider":
            suggest = "weave_network_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_network_provider: Optional['outputs.ClusterNetworkAciNetworkProvider'] = None,
                 calico_network_provider: Optional['outputs.ClusterNetworkCalicoNetworkProvider'] = None,
                 canal_network_provider: Optional['outputs.ClusterNetworkCanalNetworkProvider'] = None,
                 flannel_network_provider: Optional['outputs.ClusterNetworkFlannelNetworkProvider'] = None,
                 mtu: Optional[int] = None,
                 options: Optional[Mapping[str, Any]] = None,
                 plugin: Optional[str] = None,
                 weave_network_provider: Optional['outputs.ClusterNetworkWeaveNetworkProvider'] = None):
        """
        :param 'ClusterNetworkAciNetworkProviderArgs' aci_network_provider: Aci network provider config (list maxitems:1)
        :param 'ClusterNetworkCalicoNetworkProviderArgs' calico_network_provider: Calico network provider config (list maxitems:1)
        :param 'ClusterNetworkCanalNetworkProviderArgs' canal_network_provider: Canal network provider config (list maxitems:1)
        :param 'ClusterNetworkFlannelNetworkProviderArgs' flannel_network_provider: Flannel network provider config (list maxitems:1)
        :param int mtu: Network provider MTU. Default `0` (int)
        :param Mapping[str, Any] options: Network provider options (map)
        :param str plugin: Network provider plugin. `calico`, `canal` (default), `flannel`, `none` and `weave` are supported. (string)
        :param 'ClusterNetworkWeaveNetworkProviderArgs' weave_network_provider: Weave network provider config (list maxitems:1)
        """
        ClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aci_network_provider=aci_network_provider,
            calico_network_provider=calico_network_provider,
            canal_network_provider=canal_network_provider,
            flannel_network_provider=flannel_network_provider,
            mtu=mtu,
            options=options,
            plugin=plugin,
            weave_network_provider=weave_network_provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aci_network_provider: Optional['outputs.ClusterNetworkAciNetworkProvider'] = None,
             calico_network_provider: Optional['outputs.ClusterNetworkCalicoNetworkProvider'] = None,
             canal_network_provider: Optional['outputs.ClusterNetworkCanalNetworkProvider'] = None,
             flannel_network_provider: Optional['outputs.ClusterNetworkFlannelNetworkProvider'] = None,
             mtu: Optional[int] = None,
             options: Optional[Mapping[str, Any]] = None,
             plugin: Optional[str] = None,
             weave_network_provider: Optional['outputs.ClusterNetworkWeaveNetworkProvider'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aci_network_provider is None and 'aciNetworkProvider' in kwargs:
            aci_network_provider = kwargs['aciNetworkProvider']
        if calico_network_provider is None and 'calicoNetworkProvider' in kwargs:
            calico_network_provider = kwargs['calicoNetworkProvider']
        if canal_network_provider is None and 'canalNetworkProvider' in kwargs:
            canal_network_provider = kwargs['canalNetworkProvider']
        if flannel_network_provider is None and 'flannelNetworkProvider' in kwargs:
            flannel_network_provider = kwargs['flannelNetworkProvider']
        if weave_network_provider is None and 'weaveNetworkProvider' in kwargs:
            weave_network_provider = kwargs['weaveNetworkProvider']

        if aci_network_provider is not None:
            _setter("aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            _setter("calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            _setter("canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            _setter("flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            _setter("mtu", mtu)
        if options is not None:
            _setter("options", options)
        if plugin is not None:
            _setter("plugin", plugin)
        if weave_network_provider is not None:
            _setter("weave_network_provider", weave_network_provider)

    @property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional['outputs.ClusterNetworkAciNetworkProvider']:
        """
        Aci network provider config (list maxitems:1)
        """
        return pulumi.get(self, "aci_network_provider")

    @property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional['outputs.ClusterNetworkCalicoNetworkProvider']:
        """
        Calico network provider config (list maxitems:1)
        """
        return pulumi.get(self, "calico_network_provider")

    @property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional['outputs.ClusterNetworkCanalNetworkProvider']:
        """
        Canal network provider config (list maxitems:1)
        """
        return pulumi.get(self, "canal_network_provider")

    @property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional['outputs.ClusterNetworkFlannelNetworkProvider']:
        """
        Flannel network provider config (list maxitems:1)
        """
        return pulumi.get(self, "flannel_network_provider")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        Network provider MTU. Default `0` (int)
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Network provider options (map)
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def plugin(self) -> Optional[str]:
        """
        Network provider plugin. `calico`, `canal` (default), `flannel`, `none` and `weave` are supported. (string)
        """
        return pulumi.get(self, "plugin")

    @property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional['outputs.ClusterNetworkWeaveNetworkProvider']:
        """
        Weave network provider config (list maxitems:1)
        """
        return pulumi.get(self, "weave_network_provider")


@pulumi.output_type
class ClusterNetworkAciNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apicHosts":
            suggest = "apic_hosts"
        elif key == "apicUserCrt":
            suggest = "apic_user_crt"
        elif key == "apicUserKey":
            suggest = "apic_user_key"
        elif key == "apicUserName":
            suggest = "apic_user_name"
        elif key == "encapType":
            suggest = "encap_type"
        elif key == "externDynamic":
            suggest = "extern_dynamic"
        elif key == "externStatic":
            suggest = "extern_static"
        elif key == "infraVlan":
            suggest = "infra_vlan"
        elif key == "kubeApiVlan":
            suggest = "kube_api_vlan"
        elif key == "l3outExternalNetworks":
            suggest = "l3out_external_networks"
        elif key == "mcastRangeEnd":
            suggest = "mcast_range_end"
        elif key == "mcastRangeStart":
            suggest = "mcast_range_start"
        elif key == "nodeSubnet":
            suggest = "node_subnet"
        elif key == "nodeSvcSubnet":
            suggest = "node_svc_subnet"
        elif key == "serviceVlan":
            suggest = "service_vlan"
        elif key == "systemId":
            suggest = "system_id"
        elif key == "vrfName":
            suggest = "vrf_name"
        elif key == "vrfTenant":
            suggest = "vrf_tenant"
        elif key == "snatPortRangeEnd":
            suggest = "snat_port_range_end"
        elif key == "snatPortRangeStart":
            suggest = "snat_port_range_start"
        elif key == "snatPortsPerNode":
            suggest = "snat_ports_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkAciNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkAciNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkAciNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aep: str,
                 apic_hosts: Sequence[str],
                 apic_user_crt: str,
                 apic_user_key: str,
                 apic_user_name: str,
                 encap_type: str,
                 extern_dynamic: str,
                 extern_static: str,
                 infra_vlan: str,
                 kube_api_vlan: str,
                 l3out: str,
                 l3out_external_networks: Sequence[str],
                 mcast_range_end: str,
                 mcast_range_start: str,
                 node_subnet: str,
                 node_svc_subnet: str,
                 service_vlan: str,
                 system_id: str,
                 token: str,
                 vrf_name: str,
                 vrf_tenant: str,
                 snat_port_range_end: Optional[str] = None,
                 snat_port_range_start: Optional[str] = None,
                 snat_ports_per_node: Optional[str] = None):
        """
        :param str aep: Attachment entity profile name on aci (string)
        :param Sequence[str] apic_hosts: Ip address for apic hosts (list)
        :param str apic_user_crt: Base64 encoded certificate for aci apic user (string)
        :param str apic_user_key: Base64 encoded private key for aci apic user (string)
        :param str apic_user_name: User name for aci apic (string)
        :param str encap_type: One of the supported encap types for aci(vlan/vxlan) (string)
        :param str extern_dynamic: Subnet to use for dynamic external IPs on aci (string)
               * `extern_static"` - (Required) Subnet to use for static external IPs on aci (string)
        :param str infra_vlan: Vlan for infra network on aci (string)
        :param str kube_api_vlan: Vlan for node network on aci (string)
        :param str l3out: L3Out on aci (string)
        :param Sequence[str] l3out_external_networks: L3out external networks on aci (list)
        :param str mcast_range_end: Mcast range end address for endpoint groups on aci (string)
        :param str mcast_range_start: Mcast range start address for endpoint groups on aci (string)
        :param str node_subnet: Kubernetes node address subnet (string)
        :param str node_svc_subnet: Subnet to use for service graph endpoints on aci (string)
        :param str service_vlan: Vlan for service graph nodes on aci (string)
        :param str system_id: Unique suffix for all cluster related objects in aci (string)
        :param str token: UUID for this version of the input configuration (string)
        :param str vrf_name: VRF Name on aci (string)
        :param str vrf_tenant: Tenant for VRF on aci (string)
        :param str snat_port_range_end: Port end range for Source Network Address Translation on aci (string)
        :param str snat_port_range_start: Port start range for Source Network Address Translation on aci (string)
        :param str snat_ports_per_node: Ports per node for Source Network Address Translation on aci (string)
        """
        ClusterNetworkAciNetworkProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aep=aep,
            apic_hosts=apic_hosts,
            apic_user_crt=apic_user_crt,
            apic_user_key=apic_user_key,
            apic_user_name=apic_user_name,
            encap_type=encap_type,
            extern_dynamic=extern_dynamic,
            extern_static=extern_static,
            infra_vlan=infra_vlan,
            kube_api_vlan=kube_api_vlan,
            l3out=l3out,
            l3out_external_networks=l3out_external_networks,
            mcast_range_end=mcast_range_end,
            mcast_range_start=mcast_range_start,
            node_subnet=node_subnet,
            node_svc_subnet=node_svc_subnet,
            service_vlan=service_vlan,
            system_id=system_id,
            token=token,
            vrf_name=vrf_name,
            vrf_tenant=vrf_tenant,
            snat_port_range_end=snat_port_range_end,
            snat_port_range_start=snat_port_range_start,
            snat_ports_per_node=snat_ports_per_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aep: Optional[str] = None,
             apic_hosts: Optional[Sequence[str]] = None,
             apic_user_crt: Optional[str] = None,
             apic_user_key: Optional[str] = None,
             apic_user_name: Optional[str] = None,
             encap_type: Optional[str] = None,
             extern_dynamic: Optional[str] = None,
             extern_static: Optional[str] = None,
             infra_vlan: Optional[str] = None,
             kube_api_vlan: Optional[str] = None,
             l3out: Optional[str] = None,
             l3out_external_networks: Optional[Sequence[str]] = None,
             mcast_range_end: Optional[str] = None,
             mcast_range_start: Optional[str] = None,
             node_subnet: Optional[str] = None,
             node_svc_subnet: Optional[str] = None,
             service_vlan: Optional[str] = None,
             system_id: Optional[str] = None,
             token: Optional[str] = None,
             vrf_name: Optional[str] = None,
             vrf_tenant: Optional[str] = None,
             snat_port_range_end: Optional[str] = None,
             snat_port_range_start: Optional[str] = None,
             snat_ports_per_node: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aep is None:
            raise TypeError("Missing 'aep' argument")
        if apic_hosts is None and 'apicHosts' in kwargs:
            apic_hosts = kwargs['apicHosts']
        if apic_hosts is None:
            raise TypeError("Missing 'apic_hosts' argument")
        if apic_user_crt is None and 'apicUserCrt' in kwargs:
            apic_user_crt = kwargs['apicUserCrt']
        if apic_user_crt is None:
            raise TypeError("Missing 'apic_user_crt' argument")
        if apic_user_key is None and 'apicUserKey' in kwargs:
            apic_user_key = kwargs['apicUserKey']
        if apic_user_key is None:
            raise TypeError("Missing 'apic_user_key' argument")
        if apic_user_name is None and 'apicUserName' in kwargs:
            apic_user_name = kwargs['apicUserName']
        if apic_user_name is None:
            raise TypeError("Missing 'apic_user_name' argument")
        if encap_type is None and 'encapType' in kwargs:
            encap_type = kwargs['encapType']
        if encap_type is None:
            raise TypeError("Missing 'encap_type' argument")
        if extern_dynamic is None and 'externDynamic' in kwargs:
            extern_dynamic = kwargs['externDynamic']
        if extern_dynamic is None:
            raise TypeError("Missing 'extern_dynamic' argument")
        if extern_static is None and 'externStatic' in kwargs:
            extern_static = kwargs['externStatic']
        if extern_static is None:
            raise TypeError("Missing 'extern_static' argument")
        if infra_vlan is None and 'infraVlan' in kwargs:
            infra_vlan = kwargs['infraVlan']
        if infra_vlan is None:
            raise TypeError("Missing 'infra_vlan' argument")
        if kube_api_vlan is None and 'kubeApiVlan' in kwargs:
            kube_api_vlan = kwargs['kubeApiVlan']
        if kube_api_vlan is None:
            raise TypeError("Missing 'kube_api_vlan' argument")
        if l3out is None:
            raise TypeError("Missing 'l3out' argument")
        if l3out_external_networks is None and 'l3outExternalNetworks' in kwargs:
            l3out_external_networks = kwargs['l3outExternalNetworks']
        if l3out_external_networks is None:
            raise TypeError("Missing 'l3out_external_networks' argument")
        if mcast_range_end is None and 'mcastRangeEnd' in kwargs:
            mcast_range_end = kwargs['mcastRangeEnd']
        if mcast_range_end is None:
            raise TypeError("Missing 'mcast_range_end' argument")
        if mcast_range_start is None and 'mcastRangeStart' in kwargs:
            mcast_range_start = kwargs['mcastRangeStart']
        if mcast_range_start is None:
            raise TypeError("Missing 'mcast_range_start' argument")
        if node_subnet is None and 'nodeSubnet' in kwargs:
            node_subnet = kwargs['nodeSubnet']
        if node_subnet is None:
            raise TypeError("Missing 'node_subnet' argument")
        if node_svc_subnet is None and 'nodeSvcSubnet' in kwargs:
            node_svc_subnet = kwargs['nodeSvcSubnet']
        if node_svc_subnet is None:
            raise TypeError("Missing 'node_svc_subnet' argument")
        if service_vlan is None and 'serviceVlan' in kwargs:
            service_vlan = kwargs['serviceVlan']
        if service_vlan is None:
            raise TypeError("Missing 'service_vlan' argument")
        if system_id is None and 'systemId' in kwargs:
            system_id = kwargs['systemId']
        if system_id is None:
            raise TypeError("Missing 'system_id' argument")
        if token is None:
            raise TypeError("Missing 'token' argument")
        if vrf_name is None and 'vrfName' in kwargs:
            vrf_name = kwargs['vrfName']
        if vrf_name is None:
            raise TypeError("Missing 'vrf_name' argument")
        if vrf_tenant is None and 'vrfTenant' in kwargs:
            vrf_tenant = kwargs['vrfTenant']
        if vrf_tenant is None:
            raise TypeError("Missing 'vrf_tenant' argument")
        if snat_port_range_end is None and 'snatPortRangeEnd' in kwargs:
            snat_port_range_end = kwargs['snatPortRangeEnd']
        if snat_port_range_start is None and 'snatPortRangeStart' in kwargs:
            snat_port_range_start = kwargs['snatPortRangeStart']
        if snat_ports_per_node is None and 'snatPortsPerNode' in kwargs:
            snat_ports_per_node = kwargs['snatPortsPerNode']

        _setter("aep", aep)
        _setter("apic_hosts", apic_hosts)
        _setter("apic_user_crt", apic_user_crt)
        _setter("apic_user_key", apic_user_key)
        _setter("apic_user_name", apic_user_name)
        _setter("encap_type", encap_type)
        _setter("extern_dynamic", extern_dynamic)
        _setter("extern_static", extern_static)
        _setter("infra_vlan", infra_vlan)
        _setter("kube_api_vlan", kube_api_vlan)
        _setter("l3out", l3out)
        _setter("l3out_external_networks", l3out_external_networks)
        _setter("mcast_range_end", mcast_range_end)
        _setter("mcast_range_start", mcast_range_start)
        _setter("node_subnet", node_subnet)
        _setter("node_svc_subnet", node_svc_subnet)
        _setter("service_vlan", service_vlan)
        _setter("system_id", system_id)
        _setter("token", token)
        _setter("vrf_name", vrf_name)
        _setter("vrf_tenant", vrf_tenant)
        if snat_port_range_end is not None:
            _setter("snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            _setter("snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            _setter("snat_ports_per_node", snat_ports_per_node)

    @property
    @pulumi.getter
    def aep(self) -> str:
        """
        Attachment entity profile name on aci (string)
        """
        return pulumi.get(self, "aep")

    @property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> Sequence[str]:
        """
        Ip address for apic hosts (list)
        """
        return pulumi.get(self, "apic_hosts")

    @property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> str:
        """
        Base64 encoded certificate for aci apic user (string)
        """
        return pulumi.get(self, "apic_user_crt")

    @property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> str:
        """
        Base64 encoded private key for aci apic user (string)
        """
        return pulumi.get(self, "apic_user_key")

    @property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> str:
        """
        User name for aci apic (string)
        """
        return pulumi.get(self, "apic_user_name")

    @property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> str:
        """
        One of the supported encap types for aci(vlan/vxlan) (string)
        """
        return pulumi.get(self, "encap_type")

    @property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> str:
        """
        Subnet to use for dynamic external IPs on aci (string)
        * `extern_static"` - (Required) Subnet to use for static external IPs on aci (string)
        """
        return pulumi.get(self, "extern_dynamic")

    @property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> str:
        return pulumi.get(self, "extern_static")

    @property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> str:
        """
        Vlan for infra network on aci (string)
        """
        return pulumi.get(self, "infra_vlan")

    @property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> str:
        """
        Vlan for node network on aci (string)
        """
        return pulumi.get(self, "kube_api_vlan")

    @property
    @pulumi.getter
    def l3out(self) -> str:
        """
        L3Out on aci (string)
        """
        return pulumi.get(self, "l3out")

    @property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> Sequence[str]:
        """
        L3out external networks on aci (list)
        """
        return pulumi.get(self, "l3out_external_networks")

    @property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> str:
        """
        Mcast range end address for endpoint groups on aci (string)
        """
        return pulumi.get(self, "mcast_range_end")

    @property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> str:
        """
        Mcast range start address for endpoint groups on aci (string)
        """
        return pulumi.get(self, "mcast_range_start")

    @property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> str:
        """
        Kubernetes node address subnet (string)
        """
        return pulumi.get(self, "node_subnet")

    @property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> str:
        """
        Subnet to use for service graph endpoints on aci (string)
        """
        return pulumi.get(self, "node_svc_subnet")

    @property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> str:
        """
        Vlan for service graph nodes on aci (string)
        """
        return pulumi.get(self, "service_vlan")

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> str:
        """
        Unique suffix for all cluster related objects in aci (string)
        """
        return pulumi.get(self, "system_id")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        UUID for this version of the input configuration (string)
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> str:
        """
        VRF Name on aci (string)
        """
        return pulumi.get(self, "vrf_name")

    @property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> str:
        """
        Tenant for VRF on aci (string)
        """
        return pulumi.get(self, "vrf_tenant")

    @property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[str]:
        """
        Port end range for Source Network Address Translation on aci (string)
        """
        return pulumi.get(self, "snat_port_range_end")

    @property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[str]:
        """
        Port start range for Source Network Address Translation on aci (string)
        """
        return pulumi.get(self, "snat_port_range_start")

    @property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[str]:
        """
        Ports per node for Source Network Address Translation on aci (string)
        """
        return pulumi.get(self, "snat_ports_per_node")


@pulumi.output_type
class ClusterNetworkCalicoNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkCalicoNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkCalicoNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkCalicoNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None):
        """
        :param str cloud_provider: RKE k8s cluster cloud provider configuration [rke-cloud-providers](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/) (list maxitems:1)
        """
        ClusterNetworkCalicoNetworkProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloud_provider is None and 'cloudProvider' in kwargs:
            cloud_provider = kwargs['cloudProvider']

        if cloud_provider is not None:
            _setter("cloud_provider", cloud_provider)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        RKE k8s cluster cloud provider configuration [rke-cloud-providers](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/) (list maxitems:1)
        """
        return pulumi.get(self, "cloud_provider")


@pulumi.output_type
class ClusterNetworkCanalNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[str] = None):
        """
        :param str iface: Flannel network interface (string)
        """
        ClusterNetworkCanalNetworkProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iface=iface,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iface: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if iface is not None:
            _setter("iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[str]:
        """
        Flannel network interface (string)
        """
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterNetworkFlannelNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[str] = None):
        """
        :param str iface: Flannel network interface (string)
        """
        ClusterNetworkFlannelNetworkProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iface=iface,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iface: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if iface is not None:
            _setter("iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[str]:
        """
        Flannel network interface (string)
        """
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterNetworkWeaveNetworkProvider(dict):
    def __init__(__self__, *,
                 password: str):
        """
        :param str password: Registry password (string)
        """
        ClusterNetworkWeaveNetworkProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")

        _setter("password", password)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerSocket":
            suggest = "docker_socket"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "internalAddress":
            suggest = "internal_address"
        elif key == "nodeName":
            suggest = "node_name"
        elif key == "rolesDeprecated":
            suggest = "roles_deprecated"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshCert":
            suggest = "ssh_cert"
        elif key == "sshCertPath":
            suggest = "ssh_cert_path"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 roles: Sequence[str],
                 user: str,
                 docker_socket: Optional[str] = None,
                 hostname_override: Optional[str] = None,
                 internal_address: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 node_name: Optional[str] = None,
                 port: Optional[str] = None,
                 roles_deprecated: Optional[str] = None,
                 ssh_agent_auth: Optional[bool] = None,
                 ssh_cert: Optional[str] = None,
                 ssh_cert_path: Optional[str] = None,
                 ssh_key: Optional[str] = None,
                 ssh_key_path: Optional[str] = None,
                 taints: Optional[Sequence['outputs.ClusterNodeTaint']] = None):
        """
        :param str address: Address ip for node (string)
        :param Sequence[str] roles: Node roles in k8s cluster. `controlplane`, `etcd` and `worker` are supported. (list)
        :param str user: Registry user (string)
        :param str docker_socket: Docker socket on the node that will be used in tunneling (string)
        :param str hostname_override: Hostname override for node (string)
        :param str internal_address: Internal address that will be used for components communication (string)
        :param Mapping[str, Any] labels: Node labels (map)
        :param str node_name: Name of the host provisioned via docker machine (string)
        :param str port: Port used for SSH communication (string)
        :param bool ssh_agent_auth: SSH Agent Auth enable (bool)
        :param str ssh_cert: SSH Certificate (string)
        :param str ssh_cert_path: SSH Certificate Path (string)
        :param str ssh_key: SSH Private Key (string)
        :param str ssh_key_path: SSH Private Key Path (string)
        :param Sequence['ClusterNodeTaintArgs'] taints: Node taints (list)
        """
        ClusterNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            roles=roles,
            user=user,
            docker_socket=docker_socket,
            hostname_override=hostname_override,
            internal_address=internal_address,
            labels=labels,
            node_name=node_name,
            port=port,
            roles_deprecated=roles_deprecated,
            ssh_agent_auth=ssh_agent_auth,
            ssh_cert=ssh_cert,
            ssh_cert_path=ssh_cert_path,
            ssh_key=ssh_key,
            ssh_key_path=ssh_key_path,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             user: Optional[str] = None,
             docker_socket: Optional[str] = None,
             hostname_override: Optional[str] = None,
             internal_address: Optional[str] = None,
             labels: Optional[Mapping[str, Any]] = None,
             node_name: Optional[str] = None,
             port: Optional[str] = None,
             roles_deprecated: Optional[str] = None,
             ssh_agent_auth: Optional[bool] = None,
             ssh_cert: Optional[str] = None,
             ssh_cert_path: Optional[str] = None,
             ssh_key: Optional[str] = None,
             ssh_key_path: Optional[str] = None,
             taints: Optional[Sequence['outputs.ClusterNodeTaint']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if roles is None:
            raise TypeError("Missing 'roles' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")
        if docker_socket is None and 'dockerSocket' in kwargs:
            docker_socket = kwargs['dockerSocket']
        if hostname_override is None and 'hostnameOverride' in kwargs:
            hostname_override = kwargs['hostnameOverride']
        if internal_address is None and 'internalAddress' in kwargs:
            internal_address = kwargs['internalAddress']
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']
        if roles_deprecated is None and 'rolesDeprecated' in kwargs:
            roles_deprecated = kwargs['rolesDeprecated']
        if ssh_agent_auth is None and 'sshAgentAuth' in kwargs:
            ssh_agent_auth = kwargs['sshAgentAuth']
        if ssh_cert is None and 'sshCert' in kwargs:
            ssh_cert = kwargs['sshCert']
        if ssh_cert_path is None and 'sshCertPath' in kwargs:
            ssh_cert_path = kwargs['sshCertPath']
        if ssh_key is None and 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']
        if ssh_key_path is None and 'sshKeyPath' in kwargs:
            ssh_key_path = kwargs['sshKeyPath']

        _setter("address", address)
        _setter("roles", roles)
        _setter("user", user)
        if docker_socket is not None:
            _setter("docker_socket", docker_socket)
        if hostname_override is not None:
            _setter("hostname_override", hostname_override)
        if internal_address is not None:
            _setter("internal_address", internal_address)
        if labels is not None:
            _setter("labels", labels)
        if node_name is not None:
            _setter("node_name", node_name)
        if port is not None:
            _setter("port", port)
        if roles_deprecated is not None:
            _setter("roles_deprecated", roles_deprecated)
        if ssh_agent_auth is not None:
            _setter("ssh_agent_auth", ssh_agent_auth)
        if ssh_cert is not None:
            _setter("ssh_cert", ssh_cert)
        if ssh_cert_path is not None:
            _setter("ssh_cert_path", ssh_cert_path)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if ssh_key_path is not None:
            _setter("ssh_key_path", ssh_key_path)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        Node roles in k8s cluster. `controlplane`, `etcd` and `worker` are supported. (list)
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> Optional[str]:
        """
        Docker socket on the node that will be used in tunneling (string)
        """
        return pulumi.get(self, "docker_socket")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[str]:
        """
        Hostname override for node (string)
        """
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[str]:
        """
        Internal address that will be used for components communication (string)
        """
        return pulumi.get(self, "internal_address")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Node labels (map)
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the host provisioned via docker machine (string)
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port used for SSH communication (string)
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rolesDeprecated")
    def roles_deprecated(self) -> Optional[str]:
        warnings.warn("""Use role instead""", DeprecationWarning)
        pulumi.log.warn("""roles_deprecated is deprecated: Use role instead""")

        return pulumi.get(self, "roles_deprecated")

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[bool]:
        """
        SSH Agent Auth enable (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @property
    @pulumi.getter(name="sshCert")
    def ssh_cert(self) -> Optional[str]:
        """
        SSH Certificate (string)
        """
        return pulumi.get(self, "ssh_cert")

    @property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[str]:
        """
        SSH Certificate Path (string)
        """
        return pulumi.get(self, "ssh_cert_path")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        """
        SSH Private Key (string)
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[str]:
        """
        SSH Private Key Path (string)
        """
        return pulumi.get(self, "ssh_key_path")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterNodeTaint']]:
        """
        Node taints (list)
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class ClusterNodeTaint(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 effect: Optional[str] = None):
        """
        :param str key: TLS key for etcd service (string)
        :param str value: Taint value (string)
        :param str effect: Taint effect. `NoExecute`, `NoSchedule` (default) and `PreferNoSchedule` are supported (string)
        """
        ClusterNodeTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
            effect=effect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             effect: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)
        if effect is not None:
            _setter("effect", effect)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        TLS key for etcd service (string)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Taint value (string)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Taint effect. `NoExecute`, `NoSchedule` (default) and `PreferNoSchedule` are supported (string)
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class ClusterPrivateRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPrivateRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPrivateRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPrivateRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 is_default: Optional[bool] = None,
                 password: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str url: Registry URL (string)
        :param bool is_default: Set as default registry. Default `false` (bool)
        :param str password: Registry password (string)
        :param str user: Registry user (string)
        """
        ClusterPrivateRegistry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            is_default=is_default,
            password=password,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             is_default: Optional[bool] = None,
             password: Optional[str] = None,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']

        _setter("url", url)
        if is_default is not None:
            _setter("is_default", is_default)
        if password is not None:
            _setter("password", password)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Set as default registry. Default `false` (bool)
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ClusterRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restore: Optional[bool] = None,
                 snapshot_name: Optional[str] = None):
        """
        :param bool restore: RKE k8s cluster restore configuration (list maxitems:1)
        :param str snapshot_name: Snapshot name (string)
        """
        ClusterRestore._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            restore=restore,
            snapshot_name=snapshot_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             restore: Optional[bool] = None,
             snapshot_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshot_name is None and 'snapshotName' in kwargs:
            snapshot_name = kwargs['snapshotName']

        if restore is not None:
            _setter("restore", restore)
        if snapshot_name is not None:
            _setter("snapshot_name", snapshot_name)

    @property
    @pulumi.getter
    def restore(self) -> Optional[bool]:
        """
        RKE k8s cluster restore configuration (list maxitems:1)
        """
        return pulumi.get(self, "restore")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        Snapshot name (string)
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class ClusterRotateCertificates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRotateCertificates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRotateCertificates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRotateCertificates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[bool] = None,
                 services: Optional[Sequence[str]] = None):
        """
        :param bool ca_certificates: Rotate CA Certificates. Default `false` (bool)
        :param Sequence[str] services: RKE k8s cluster services (list maxitems:1)
        """
        ClusterRotateCertificates._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ca_certificates=ca_certificates,
            services=services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ca_certificates: Optional[bool] = None,
             services: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ca_certificates is None and 'caCertificates' in kwargs:
            ca_certificates = kwargs['caCertificates']

        if ca_certificates is not None:
            _setter("ca_certificates", ca_certificates)
        if services is not None:
            _setter("services", services)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[bool]:
        """
        Rotate CA Certificates. Default `false` (bool)
        """
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[str]]:
        """
        RKE k8s cluster services (list maxitems:1)
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class ClusterRunningSystemImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciCniDeployContainer":
            suggest = "aci_cni_deploy_container"
        elif key == "aciControllerContainer":
            suggest = "aci_controller_container"
        elif key == "aciHostContainer":
            suggest = "aci_host_container"
        elif key == "aciMcastContainer":
            suggest = "aci_mcast_container"
        elif key == "aciOpflexContainer":
            suggest = "aci_opflex_container"
        elif key == "aciOvsContainer":
            suggest = "aci_ovs_container"
        elif key == "calicoCni":
            suggest = "calico_cni"
        elif key == "calicoControllers":
            suggest = "calico_controllers"
        elif key == "calicoCtl":
            suggest = "calico_ctl"
        elif key == "calicoFlexVol":
            suggest = "calico_flex_vol"
        elif key == "calicoNode":
            suggest = "calico_node"
        elif key == "canalCni":
            suggest = "canal_cni"
        elif key == "canalFlannel":
            suggest = "canal_flannel"
        elif key == "canalFlexVol":
            suggest = "canal_flex_vol"
        elif key == "canalNode":
            suggest = "canal_node"
        elif key == "certDownloader":
            suggest = "cert_downloader"
        elif key == "corednsAutoscaler":
            suggest = "coredns_autoscaler"
        elif key == "flannelCni":
            suggest = "flannel_cni"
        elif key == "ingressBackend":
            suggest = "ingress_backend"
        elif key == "kubeDns":
            suggest = "kube_dns"
        elif key == "kubeDnsAutoscaler":
            suggest = "kube_dns_autoscaler"
        elif key == "kubeDnsSidecar":
            suggest = "kube_dns_sidecar"
        elif key == "kubernetesServicesSidecar":
            suggest = "kubernetes_services_sidecar"
        elif key == "metricsServer":
            suggest = "metrics_server"
        elif key == "nginxProxy":
            suggest = "nginx_proxy"
        elif key == "podInfraContainer":
            suggest = "pod_infra_container"
        elif key == "weaveCni":
            suggest = "weave_cni"
        elif key == "weaveNode":
            suggest = "weave_node"
        elif key == "windowsPodInfraContainer":
            suggest = "windows_pod_infra_container"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRunningSystemImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRunningSystemImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRunningSystemImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_cni_deploy_container: Optional[str] = None,
                 aci_controller_container: Optional[str] = None,
                 aci_host_container: Optional[str] = None,
                 aci_mcast_container: Optional[str] = None,
                 aci_opflex_container: Optional[str] = None,
                 aci_ovs_container: Optional[str] = None,
                 alpine: Optional[str] = None,
                 calico_cni: Optional[str] = None,
                 calico_controllers: Optional[str] = None,
                 calico_ctl: Optional[str] = None,
                 calico_flex_vol: Optional[str] = None,
                 calico_node: Optional[str] = None,
                 canal_cni: Optional[str] = None,
                 canal_flannel: Optional[str] = None,
                 canal_flex_vol: Optional[str] = None,
                 canal_node: Optional[str] = None,
                 cert_downloader: Optional[str] = None,
                 coredns: Optional[str] = None,
                 coredns_autoscaler: Optional[str] = None,
                 dnsmasq: Optional[str] = None,
                 etcd: Optional[str] = None,
                 flannel: Optional[str] = None,
                 flannel_cni: Optional[str] = None,
                 ingress: Optional[str] = None,
                 ingress_backend: Optional[str] = None,
                 kube_dns: Optional[str] = None,
                 kube_dns_autoscaler: Optional[str] = None,
                 kube_dns_sidecar: Optional[str] = None,
                 kubernetes: Optional[str] = None,
                 kubernetes_services_sidecar: Optional[str] = None,
                 metrics_server: Optional[str] = None,
                 nginx_proxy: Optional[str] = None,
                 nodelocal: Optional[str] = None,
                 pod_infra_container: Optional[str] = None,
                 weave_cni: Optional[str] = None,
                 weave_node: Optional[str] = None,
                 windows_pod_infra_container: Optional[str] = None):
        """
        :param str aci_cni_deploy_container: Docker image for aci_cni_deploy_container (string)
        :param str aci_controller_container: Docker image for aci_controller_container (string)
        :param str aci_host_container: Docker image for aci_host_container (string)
        :param str aci_mcast_container: Docker image for aci_mcast_container (string)
        :param str aci_opflex_container: Docker image for aci_opflex_container (string)
        :param str aci_ovs_container: Docker image for aci_ovs_container (string)
        :param str alpine: Docker image for alpine (string)
        :param str calico_cni: Docker image for calico_cni (string)
        :param str calico_controllers: Docker image for calico_controllers (string)
        :param str calico_ctl: Docker image for calico_ctl (string)
        :param str calico_flex_vol: Docker image for calico_flex_vol (string)
        :param str calico_node: Docker image for calico_node (string)
        :param str canal_cni: Docker image for canal_cni (string)
        :param str canal_flannel: Docker image for canal_flannel (string)
        :param str canal_flex_vol: Docker image for canal_flex_vol (string)
        :param str canal_node: Docker image for canal_node (string)
        :param str cert_downloader: Docker image for cert_downloader (string)
        :param str coredns: Docker image for coredns (string)
        :param str coredns_autoscaler: Docker image for coredns_autoscaler (string)
        :param str dnsmasq: Docker image for dnsmasq (string)
        :param str etcd: Docker image for etcd (string)
        :param str flannel: Docker image for flannel (string)
        :param str flannel_cni: Docker image for flannel_cni (string)
        :param str ingress: RKE k8s cluster ingress controller configuration (list maxitems:1)
        :param str ingress_backend: Docker image for ingress_backend (string)
        :param str kube_dns: Docker image for kube_dns (string)
        :param str kube_dns_autoscaler: Docker image for kube_dns_autoscaler (string)
        :param str kube_dns_sidecar: Docker image for kube_dns_sidecar (string)
        :param str kubernetes: Docker image for kubernetes (string)
        :param str kubernetes_services_sidecar: Docker image for kubernetes_services_sidecar (string)
        :param str metrics_server: Docker image for metrics_server (string)
        :param str nginx_proxy: Docker image for nginx_proxy (string)
        :param str nodelocal: Docker image for nodelocal (string)
        :param str pod_infra_container: Docker image for pod_infra_container (string)
        :param str weave_cni: Docker image for weave_cni (string)
        :param str weave_node: Docker image for weave_node (string)
        :param str windows_pod_infra_container: Docker image for windows_pod_infra_container (string)
        """
        ClusterRunningSystemImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aci_cni_deploy_container=aci_cni_deploy_container,
            aci_controller_container=aci_controller_container,
            aci_host_container=aci_host_container,
            aci_mcast_container=aci_mcast_container,
            aci_opflex_container=aci_opflex_container,
            aci_ovs_container=aci_ovs_container,
            alpine=alpine,
            calico_cni=calico_cni,
            calico_controllers=calico_controllers,
            calico_ctl=calico_ctl,
            calico_flex_vol=calico_flex_vol,
            calico_node=calico_node,
            canal_cni=canal_cni,
            canal_flannel=canal_flannel,
            canal_flex_vol=canal_flex_vol,
            canal_node=canal_node,
            cert_downloader=cert_downloader,
            coredns=coredns,
            coredns_autoscaler=coredns_autoscaler,
            dnsmasq=dnsmasq,
            etcd=etcd,
            flannel=flannel,
            flannel_cni=flannel_cni,
            ingress=ingress,
            ingress_backend=ingress_backend,
            kube_dns=kube_dns,
            kube_dns_autoscaler=kube_dns_autoscaler,
            kube_dns_sidecar=kube_dns_sidecar,
            kubernetes=kubernetes,
            kubernetes_services_sidecar=kubernetes_services_sidecar,
            metrics_server=metrics_server,
            nginx_proxy=nginx_proxy,
            nodelocal=nodelocal,
            pod_infra_container=pod_infra_container,
            weave_cni=weave_cni,
            weave_node=weave_node,
            windows_pod_infra_container=windows_pod_infra_container,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aci_cni_deploy_container: Optional[str] = None,
             aci_controller_container: Optional[str] = None,
             aci_host_container: Optional[str] = None,
             aci_mcast_container: Optional[str] = None,
             aci_opflex_container: Optional[str] = None,
             aci_ovs_container: Optional[str] = None,
             alpine: Optional[str] = None,
             calico_cni: Optional[str] = None,
             calico_controllers: Optional[str] = None,
             calico_ctl: Optional[str] = None,
             calico_flex_vol: Optional[str] = None,
             calico_node: Optional[str] = None,
             canal_cni: Optional[str] = None,
             canal_flannel: Optional[str] = None,
             canal_flex_vol: Optional[str] = None,
             canal_node: Optional[str] = None,
             cert_downloader: Optional[str] = None,
             coredns: Optional[str] = None,
             coredns_autoscaler: Optional[str] = None,
             dnsmasq: Optional[str] = None,
             etcd: Optional[str] = None,
             flannel: Optional[str] = None,
             flannel_cni: Optional[str] = None,
             ingress: Optional[str] = None,
             ingress_backend: Optional[str] = None,
             kube_dns: Optional[str] = None,
             kube_dns_autoscaler: Optional[str] = None,
             kube_dns_sidecar: Optional[str] = None,
             kubernetes: Optional[str] = None,
             kubernetes_services_sidecar: Optional[str] = None,
             metrics_server: Optional[str] = None,
             nginx_proxy: Optional[str] = None,
             nodelocal: Optional[str] = None,
             pod_infra_container: Optional[str] = None,
             weave_cni: Optional[str] = None,
             weave_node: Optional[str] = None,
             windows_pod_infra_container: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aci_cni_deploy_container is None and 'aciCniDeployContainer' in kwargs:
            aci_cni_deploy_container = kwargs['aciCniDeployContainer']
        if aci_controller_container is None and 'aciControllerContainer' in kwargs:
            aci_controller_container = kwargs['aciControllerContainer']
        if aci_host_container is None and 'aciHostContainer' in kwargs:
            aci_host_container = kwargs['aciHostContainer']
        if aci_mcast_container is None and 'aciMcastContainer' in kwargs:
            aci_mcast_container = kwargs['aciMcastContainer']
        if aci_opflex_container is None and 'aciOpflexContainer' in kwargs:
            aci_opflex_container = kwargs['aciOpflexContainer']
        if aci_ovs_container is None and 'aciOvsContainer' in kwargs:
            aci_ovs_container = kwargs['aciOvsContainer']
        if calico_cni is None and 'calicoCni' in kwargs:
            calico_cni = kwargs['calicoCni']
        if calico_controllers is None and 'calicoControllers' in kwargs:
            calico_controllers = kwargs['calicoControllers']
        if calico_ctl is None and 'calicoCtl' in kwargs:
            calico_ctl = kwargs['calicoCtl']
        if calico_flex_vol is None and 'calicoFlexVol' in kwargs:
            calico_flex_vol = kwargs['calicoFlexVol']
        if calico_node is None and 'calicoNode' in kwargs:
            calico_node = kwargs['calicoNode']
        if canal_cni is None and 'canalCni' in kwargs:
            canal_cni = kwargs['canalCni']
        if canal_flannel is None and 'canalFlannel' in kwargs:
            canal_flannel = kwargs['canalFlannel']
        if canal_flex_vol is None and 'canalFlexVol' in kwargs:
            canal_flex_vol = kwargs['canalFlexVol']
        if canal_node is None and 'canalNode' in kwargs:
            canal_node = kwargs['canalNode']
        if cert_downloader is None and 'certDownloader' in kwargs:
            cert_downloader = kwargs['certDownloader']
        if coredns_autoscaler is None and 'corednsAutoscaler' in kwargs:
            coredns_autoscaler = kwargs['corednsAutoscaler']
        if flannel_cni is None and 'flannelCni' in kwargs:
            flannel_cni = kwargs['flannelCni']
        if ingress_backend is None and 'ingressBackend' in kwargs:
            ingress_backend = kwargs['ingressBackend']
        if kube_dns is None and 'kubeDns' in kwargs:
            kube_dns = kwargs['kubeDns']
        if kube_dns_autoscaler is None and 'kubeDnsAutoscaler' in kwargs:
            kube_dns_autoscaler = kwargs['kubeDnsAutoscaler']
        if kube_dns_sidecar is None and 'kubeDnsSidecar' in kwargs:
            kube_dns_sidecar = kwargs['kubeDnsSidecar']
        if kubernetes_services_sidecar is None and 'kubernetesServicesSidecar' in kwargs:
            kubernetes_services_sidecar = kwargs['kubernetesServicesSidecar']
        if metrics_server is None and 'metricsServer' in kwargs:
            metrics_server = kwargs['metricsServer']
        if nginx_proxy is None and 'nginxProxy' in kwargs:
            nginx_proxy = kwargs['nginxProxy']
        if pod_infra_container is None and 'podInfraContainer' in kwargs:
            pod_infra_container = kwargs['podInfraContainer']
        if weave_cni is None and 'weaveCni' in kwargs:
            weave_cni = kwargs['weaveCni']
        if weave_node is None and 'weaveNode' in kwargs:
            weave_node = kwargs['weaveNode']
        if windows_pod_infra_container is None and 'windowsPodInfraContainer' in kwargs:
            windows_pod_infra_container = kwargs['windowsPodInfraContainer']

        if aci_cni_deploy_container is not None:
            _setter("aci_cni_deploy_container", aci_cni_deploy_container)
        if aci_controller_container is not None:
            _setter("aci_controller_container", aci_controller_container)
        if aci_host_container is not None:
            _setter("aci_host_container", aci_host_container)
        if aci_mcast_container is not None:
            _setter("aci_mcast_container", aci_mcast_container)
        if aci_opflex_container is not None:
            _setter("aci_opflex_container", aci_opflex_container)
        if aci_ovs_container is not None:
            _setter("aci_ovs_container", aci_ovs_container)
        if alpine is not None:
            _setter("alpine", alpine)
        if calico_cni is not None:
            _setter("calico_cni", calico_cni)
        if calico_controllers is not None:
            _setter("calico_controllers", calico_controllers)
        if calico_ctl is not None:
            _setter("calico_ctl", calico_ctl)
        if calico_flex_vol is not None:
            _setter("calico_flex_vol", calico_flex_vol)
        if calico_node is not None:
            _setter("calico_node", calico_node)
        if canal_cni is not None:
            _setter("canal_cni", canal_cni)
        if canal_flannel is not None:
            _setter("canal_flannel", canal_flannel)
        if canal_flex_vol is not None:
            _setter("canal_flex_vol", canal_flex_vol)
        if canal_node is not None:
            _setter("canal_node", canal_node)
        if cert_downloader is not None:
            _setter("cert_downloader", cert_downloader)
        if coredns is not None:
            _setter("coredns", coredns)
        if coredns_autoscaler is not None:
            _setter("coredns_autoscaler", coredns_autoscaler)
        if dnsmasq is not None:
            _setter("dnsmasq", dnsmasq)
        if etcd is not None:
            _setter("etcd", etcd)
        if flannel is not None:
            _setter("flannel", flannel)
        if flannel_cni is not None:
            _setter("flannel_cni", flannel_cni)
        if ingress is not None:
            _setter("ingress", ingress)
        if ingress_backend is not None:
            _setter("ingress_backend", ingress_backend)
        if kube_dns is not None:
            _setter("kube_dns", kube_dns)
        if kube_dns_autoscaler is not None:
            _setter("kube_dns_autoscaler", kube_dns_autoscaler)
        if kube_dns_sidecar is not None:
            _setter("kube_dns_sidecar", kube_dns_sidecar)
        if kubernetes is not None:
            _setter("kubernetes", kubernetes)
        if kubernetes_services_sidecar is not None:
            _setter("kubernetes_services_sidecar", kubernetes_services_sidecar)
        if metrics_server is not None:
            _setter("metrics_server", metrics_server)
        if nginx_proxy is not None:
            _setter("nginx_proxy", nginx_proxy)
        if nodelocal is not None:
            _setter("nodelocal", nodelocal)
        if pod_infra_container is not None:
            _setter("pod_infra_container", pod_infra_container)
        if weave_cni is not None:
            _setter("weave_cni", weave_cni)
        if weave_node is not None:
            _setter("weave_node", weave_node)
        if windows_pod_infra_container is not None:
            _setter("windows_pod_infra_container", windows_pod_infra_container)

    @property
    @pulumi.getter(name="aciCniDeployContainer")
    def aci_cni_deploy_container(self) -> Optional[str]:
        """
        Docker image for aci_cni_deploy_container (string)
        """
        return pulumi.get(self, "aci_cni_deploy_container")

    @property
    @pulumi.getter(name="aciControllerContainer")
    def aci_controller_container(self) -> Optional[str]:
        """
        Docker image for aci_controller_container (string)
        """
        return pulumi.get(self, "aci_controller_container")

    @property
    @pulumi.getter(name="aciHostContainer")
    def aci_host_container(self) -> Optional[str]:
        """
        Docker image for aci_host_container (string)
        """
        return pulumi.get(self, "aci_host_container")

    @property
    @pulumi.getter(name="aciMcastContainer")
    def aci_mcast_container(self) -> Optional[str]:
        """
        Docker image for aci_mcast_container (string)
        """
        return pulumi.get(self, "aci_mcast_container")

    @property
    @pulumi.getter(name="aciOpflexContainer")
    def aci_opflex_container(self) -> Optional[str]:
        """
        Docker image for aci_opflex_container (string)
        """
        return pulumi.get(self, "aci_opflex_container")

    @property
    @pulumi.getter(name="aciOvsContainer")
    def aci_ovs_container(self) -> Optional[str]:
        """
        Docker image for aci_ovs_container (string)
        """
        return pulumi.get(self, "aci_ovs_container")

    @property
    @pulumi.getter
    def alpine(self) -> Optional[str]:
        """
        Docker image for alpine (string)
        """
        return pulumi.get(self, "alpine")

    @property
    @pulumi.getter(name="calicoCni")
    def calico_cni(self) -> Optional[str]:
        """
        Docker image for calico_cni (string)
        """
        return pulumi.get(self, "calico_cni")

    @property
    @pulumi.getter(name="calicoControllers")
    def calico_controllers(self) -> Optional[str]:
        """
        Docker image for calico_controllers (string)
        """
        return pulumi.get(self, "calico_controllers")

    @property
    @pulumi.getter(name="calicoCtl")
    def calico_ctl(self) -> Optional[str]:
        """
        Docker image for calico_ctl (string)
        """
        return pulumi.get(self, "calico_ctl")

    @property
    @pulumi.getter(name="calicoFlexVol")
    def calico_flex_vol(self) -> Optional[str]:
        """
        Docker image for calico_flex_vol (string)
        """
        return pulumi.get(self, "calico_flex_vol")

    @property
    @pulumi.getter(name="calicoNode")
    def calico_node(self) -> Optional[str]:
        """
        Docker image for calico_node (string)
        """
        return pulumi.get(self, "calico_node")

    @property
    @pulumi.getter(name="canalCni")
    def canal_cni(self) -> Optional[str]:
        """
        Docker image for canal_cni (string)
        """
        return pulumi.get(self, "canal_cni")

    @property
    @pulumi.getter(name="canalFlannel")
    def canal_flannel(self) -> Optional[str]:
        """
        Docker image for canal_flannel (string)
        """
        return pulumi.get(self, "canal_flannel")

    @property
    @pulumi.getter(name="canalFlexVol")
    def canal_flex_vol(self) -> Optional[str]:
        """
        Docker image for canal_flex_vol (string)
        """
        return pulumi.get(self, "canal_flex_vol")

    @property
    @pulumi.getter(name="canalNode")
    def canal_node(self) -> Optional[str]:
        """
        Docker image for canal_node (string)
        """
        return pulumi.get(self, "canal_node")

    @property
    @pulumi.getter(name="certDownloader")
    def cert_downloader(self) -> Optional[str]:
        """
        Docker image for cert_downloader (string)
        """
        return pulumi.get(self, "cert_downloader")

    @property
    @pulumi.getter
    def coredns(self) -> Optional[str]:
        """
        Docker image for coredns (string)
        """
        return pulumi.get(self, "coredns")

    @property
    @pulumi.getter(name="corednsAutoscaler")
    def coredns_autoscaler(self) -> Optional[str]:
        """
        Docker image for coredns_autoscaler (string)
        """
        return pulumi.get(self, "coredns_autoscaler")

    @property
    @pulumi.getter
    def dnsmasq(self) -> Optional[str]:
        """
        Docker image for dnsmasq (string)
        """
        return pulumi.get(self, "dnsmasq")

    @property
    @pulumi.getter
    def etcd(self) -> Optional[str]:
        """
        Docker image for etcd (string)
        """
        return pulumi.get(self, "etcd")

    @property
    @pulumi.getter
    def flannel(self) -> Optional[str]:
        """
        Docker image for flannel (string)
        """
        return pulumi.get(self, "flannel")

    @property
    @pulumi.getter(name="flannelCni")
    def flannel_cni(self) -> Optional[str]:
        """
        Docker image for flannel_cni (string)
        """
        return pulumi.get(self, "flannel_cni")

    @property
    @pulumi.getter
    def ingress(self) -> Optional[str]:
        """
        RKE k8s cluster ingress controller configuration (list maxitems:1)
        """
        return pulumi.get(self, "ingress")

    @property
    @pulumi.getter(name="ingressBackend")
    def ingress_backend(self) -> Optional[str]:
        """
        Docker image for ingress_backend (string)
        """
        return pulumi.get(self, "ingress_backend")

    @property
    @pulumi.getter(name="kubeDns")
    def kube_dns(self) -> Optional[str]:
        """
        Docker image for kube_dns (string)
        """
        return pulumi.get(self, "kube_dns")

    @property
    @pulumi.getter(name="kubeDnsAutoscaler")
    def kube_dns_autoscaler(self) -> Optional[str]:
        """
        Docker image for kube_dns_autoscaler (string)
        """
        return pulumi.get(self, "kube_dns_autoscaler")

    @property
    @pulumi.getter(name="kubeDnsSidecar")
    def kube_dns_sidecar(self) -> Optional[str]:
        """
        Docker image for kube_dns_sidecar (string)
        """
        return pulumi.get(self, "kube_dns_sidecar")

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[str]:
        """
        Docker image for kubernetes (string)
        """
        return pulumi.get(self, "kubernetes")

    @property
    @pulumi.getter(name="kubernetesServicesSidecar")
    def kubernetes_services_sidecar(self) -> Optional[str]:
        """
        Docker image for kubernetes_services_sidecar (string)
        """
        return pulumi.get(self, "kubernetes_services_sidecar")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[str]:
        """
        Docker image for metrics_server (string)
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter(name="nginxProxy")
    def nginx_proxy(self) -> Optional[str]:
        """
        Docker image for nginx_proxy (string)
        """
        return pulumi.get(self, "nginx_proxy")

    @property
    @pulumi.getter
    def nodelocal(self) -> Optional[str]:
        """
        Docker image for nodelocal (string)
        """
        return pulumi.get(self, "nodelocal")

    @property
    @pulumi.getter(name="podInfraContainer")
    def pod_infra_container(self) -> Optional[str]:
        """
        Docker image for pod_infra_container (string)
        """
        return pulumi.get(self, "pod_infra_container")

    @property
    @pulumi.getter(name="weaveCni")
    def weave_cni(self) -> Optional[str]:
        """
        Docker image for weave_cni (string)
        """
        return pulumi.get(self, "weave_cni")

    @property
    @pulumi.getter(name="weaveNode")
    def weave_node(self) -> Optional[str]:
        """
        Docker image for weave_node (string)
        """
        return pulumi.get(self, "weave_node")

    @property
    @pulumi.getter(name="windowsPodInfraContainer")
    def windows_pod_infra_container(self) -> Optional[str]:
        """
        Docker image for windows_pod_infra_container (string)
        """
        return pulumi.get(self, "windows_pod_infra_container")


@pulumi.output_type
class ClusterServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeApi":
            suggest = "kube_api"
        elif key == "kubeController":
            suggest = "kube_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etcd: Optional['outputs.ClusterServicesEtcd'] = None,
                 kube_api: Optional['outputs.ClusterServicesKubeApi'] = None,
                 kube_controller: Optional['outputs.ClusterServicesKubeController'] = None,
                 kubelet: Optional['outputs.ClusterServicesKubelet'] = None,
                 kubeproxy: Optional['outputs.ClusterServicesKubeproxy'] = None,
                 scheduler: Optional['outputs.ClusterServicesScheduler'] = None):
        """
        :param 'ClusterServicesEtcdArgs' etcd: Docker image for etcd (string)
        :param 'ClusterServicesKubeApiArgs' kube_api: Kube API options for RKE services (list maxitems:1)
        :param 'ClusterServicesKubeControllerArgs' kube_controller: Kube Controller options for RKE services (list maxitems:1)
        :param 'ClusterServicesKubeletArgs' kubelet: Kubelet options for RKE services (list maxitems:1)
        :param 'ClusterServicesKubeproxyArgs' kubeproxy: Kubeproxy options for RKE services (list maxitems:1)
        :param 'ClusterServicesSchedulerArgs' scheduler: Scheduler options for RKE services (list maxitems:1)
        """
        ClusterServices._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etcd=etcd,
            kube_api=kube_api,
            kube_controller=kube_controller,
            kubelet=kubelet,
            kubeproxy=kubeproxy,
            scheduler=scheduler,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etcd: Optional['outputs.ClusterServicesEtcd'] = None,
             kube_api: Optional['outputs.ClusterServicesKubeApi'] = None,
             kube_controller: Optional['outputs.ClusterServicesKubeController'] = None,
             kubelet: Optional['outputs.ClusterServicesKubelet'] = None,
             kubeproxy: Optional['outputs.ClusterServicesKubeproxy'] = None,
             scheduler: Optional['outputs.ClusterServicesScheduler'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kube_api is None and 'kubeApi' in kwargs:
            kube_api = kwargs['kubeApi']
        if kube_controller is None and 'kubeController' in kwargs:
            kube_controller = kwargs['kubeController']

        if etcd is not None:
            _setter("etcd", etcd)
        if kube_api is not None:
            _setter("kube_api", kube_api)
        if kube_controller is not None:
            _setter("kube_controller", kube_controller)
        if kubelet is not None:
            _setter("kubelet", kubelet)
        if kubeproxy is not None:
            _setter("kubeproxy", kubeproxy)
        if scheduler is not None:
            _setter("scheduler", scheduler)

    @property
    @pulumi.getter
    def etcd(self) -> Optional['outputs.ClusterServicesEtcd']:
        """
        Docker image for etcd (string)
        """
        return pulumi.get(self, "etcd")

    @property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> Optional['outputs.ClusterServicesKubeApi']:
        """
        Kube API options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_api")

    @property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> Optional['outputs.ClusterServicesKubeController']:
        """
        Kube Controller options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_controller")

    @property
    @pulumi.getter
    def kubelet(self) -> Optional['outputs.ClusterServicesKubelet']:
        """
        Kubelet options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubelet")

    @property
    @pulumi.getter
    def kubeproxy(self) -> Optional['outputs.ClusterServicesKubeproxy']:
        """
        Kubeproxy options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubeproxy")

    @property
    @pulumi.getter
    def scheduler(self) -> Optional['outputs.ClusterServicesScheduler']:
        """
        Scheduler options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class ClusterServicesEtcd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupConfig":
            suggest = "backup_config"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "externalUrls":
            suggest = "external_urls"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_config: Optional['outputs.ClusterServicesEtcdBackupConfig'] = None,
                 ca_cert: Optional[str] = None,
                 cert: Optional[str] = None,
                 creation: Optional[str] = None,
                 external_urls: Optional[Sequence[str]] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 gid: Optional[int] = None,
                 image: Optional[str] = None,
                 key: Optional[str] = None,
                 path: Optional[str] = None,
                 retention: Optional[str] = None,
                 snapshot: Optional[bool] = None,
                 uid: Optional[int] = None):
        """
        :param 'ClusterServicesEtcdBackupConfigArgs' backup_config: Backup options for etcd service. Just for Rancher v2.2.x (list maxitems:1)
        :param str ca_cert: TLS CA certificate for etcd service (string)
        :param str cert: TLS certificate for etcd service (string)
        :param str creation: Creation option for etcd service (string)
        :param Sequence[str] external_urls: External urls for etcd service (list)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param int gid: Etcd service GID. Default: `0`. For Rancher v2.3.x or above (int)
        :param str image: Docker image for scheduler service (string)
        :param str key: TLS key for etcd service (string)
        :param str path: Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param str retention: Retention for etcd backup. Default `6` (int)
        :param bool snapshot: Snapshot option for etcd service. Default `true` (bool)
        :param int uid: Etcd service UID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        ClusterServicesEtcd._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_config=backup_config,
            ca_cert=ca_cert,
            cert=cert,
            creation=creation,
            external_urls=external_urls,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            gid=gid,
            image=image,
            key=key,
            path=path,
            retention=retention,
            snapshot=snapshot,
            uid=uid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_config: Optional['outputs.ClusterServicesEtcdBackupConfig'] = None,
             ca_cert: Optional[str] = None,
             cert: Optional[str] = None,
             creation: Optional[str] = None,
             external_urls: Optional[Sequence[str]] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             gid: Optional[int] = None,
             image: Optional[str] = None,
             key: Optional[str] = None,
             path: Optional[str] = None,
             retention: Optional[str] = None,
             snapshot: Optional[bool] = None,
             uid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_config is None and 'backupConfig' in kwargs:
            backup_config = kwargs['backupConfig']
        if ca_cert is None and 'caCert' in kwargs:
            ca_cert = kwargs['caCert']
        if external_urls is None and 'externalUrls' in kwargs:
            external_urls = kwargs['externalUrls']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if backup_config is not None:
            _setter("backup_config", backup_config)
        if ca_cert is not None:
            _setter("ca_cert", ca_cert)
        if cert is not None:
            _setter("cert", cert)
        if creation is not None:
            _setter("creation", creation)
        if external_urls is not None:
            _setter("external_urls", external_urls)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if gid is not None:
            _setter("gid", gid)
        if image is not None:
            _setter("image", image)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)
        if retention is not None:
            _setter("retention", retention)
        if snapshot is not None:
            _setter("snapshot", snapshot)
        if uid is not None:
            _setter("uid", uid)

    @property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional['outputs.ClusterServicesEtcdBackupConfig']:
        """
        Backup options for etcd service. Just for Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "backup_config")

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        TLS CA certificate for etcd service (string)
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        TLS certificate for etcd service (string)
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def creation(self) -> Optional[str]:
        """
        Creation option for etcd service (string)
        """
        return pulumi.get(self, "creation")

    @property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[str]]:
        """
        External urls for etcd service (list)
        """
        return pulumi.get(self, "external_urls")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def gid(self) -> Optional[int]:
        """
        Etcd service GID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        return pulumi.get(self, "gid")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TLS key for etcd service (string)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def retention(self) -> Optional[str]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[bool]:
        """
        Snapshot option for etcd service. Default `true` (bool)
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter
    def uid(self) -> Optional[int]:
        """
        Etcd service UID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterServicesEtcdBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"
        elif key == "s3BackupConfig":
            suggest = "s3_backup_config"
        elif key == "safeTimestamp":
            suggest = "safe_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcdBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcdBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcdBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 interval_hours: Optional[int] = None,
                 retention: Optional[int] = None,
                 s3_backup_config: Optional['outputs.ClusterServicesEtcdBackupConfigS3BackupConfig'] = None,
                 safe_timestamp: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param bool enabled: Enable secrets encryption (bool)
        :param int interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param int retention: Retention for etcd backup. Default `6` (int)
        :param 'ClusterServicesEtcdBackupConfigS3BackupConfigArgs' s3_backup_config: S3 config options for etcd backup (list maxitems:1)
        :param bool safe_timestamp: Safe timestamp for etcd backup. Default: `false` (bool)
        :param int timeout: RKE node drain timeout (int)
        """
        ClusterServicesEtcdBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            interval_hours=interval_hours,
            retention=retention,
            s3_backup_config=s3_backup_config,
            safe_timestamp=safe_timestamp,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             interval_hours: Optional[int] = None,
             retention: Optional[int] = None,
             s3_backup_config: Optional['outputs.ClusterServicesEtcdBackupConfigS3BackupConfig'] = None,
             safe_timestamp: Optional[bool] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if interval_hours is None and 'intervalHours' in kwargs:
            interval_hours = kwargs['intervalHours']
        if s3_backup_config is None and 's3BackupConfig' in kwargs:
            s3_backup_config = kwargs['s3BackupConfig']
        if safe_timestamp is None and 'safeTimestamp' in kwargs:
            safe_timestamp = kwargs['safeTimestamp']

        if enabled is not None:
            _setter("enabled", enabled)
        if interval_hours is not None:
            _setter("interval_hours", interval_hours)
        if retention is not None:
            _setter("retention", retention)
        if s3_backup_config is not None:
            _setter("s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            _setter("safe_timestamp", safe_timestamp)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[int]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @property
    @pulumi.getter
    def retention(self) -> Optional[int]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.ClusterServicesEtcdBackupConfigS3BackupConfig']:
        """
        S3 config options for etcd backup (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[bool]:
        """
        Safe timestamp for etcd backup. Default: `false` (bool)
        """
        return pulumi.get(self, "safe_timestamp")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        RKE node drain timeout (int)
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterServicesEtcdBackupConfigS3BackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "customCa":
            suggest = "custom_ca"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcdBackupConfigS3BackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_name: Optional[str] = None,
                 custom_ca: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 folder: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str access_key: Access key for S3 service (string)
        :param str bucket_name: Bucket name for S3 service (string)
        :param str custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param str endpoint: Endpoint for S3 service (string)
        :param str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param str region: Region for S3 service (string)
        :param str secret_key: Secret key for S3 service (string)
        """
        ClusterServicesEtcdBackupConfigS3BackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            bucket_name=bucket_name,
            custom_ca=custom_ca,
            endpoint=endpoint,
            folder=folder,
            region=region,
            secret_key=secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[str] = None,
             bucket_name: Optional[str] = None,
             custom_ca: Optional[str] = None,
             endpoint: Optional[str] = None,
             folder: Optional[str] = None,
             region: Optional[str] = None,
             secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_key is None and 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if custom_ca is None and 'customCa' in kwargs:
            custom_ca = kwargs['customCa']
        if secret_key is None and 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']

        if access_key is not None:
            _setter("access_key", access_key)
        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if custom_ca is not None:
            _setter("custom_ca", custom_ca)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if folder is not None:
            _setter("folder", folder)
        if region is not None:
            _setter("region", region)
        if secret_key is not None:
            _setter("secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for S3 service (string)
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[str]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def folder(self) -> Optional[str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for S3 service (string)
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ClusterServicesEtcdDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupConfig":
            suggest = "backup_config"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "externalUrls":
            suggest = "external_urls"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcdDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcdDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcdDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_config: Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfig'] = None,
                 ca_cert: Optional[str] = None,
                 cert: Optional[str] = None,
                 creation: Optional[str] = None,
                 external_urls: Optional[Sequence[str]] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 gid: Optional[int] = None,
                 image: Optional[str] = None,
                 key: Optional[str] = None,
                 path: Optional[str] = None,
                 retention: Optional[str] = None,
                 snapshot: Optional[bool] = None,
                 uid: Optional[int] = None):
        """
        :param 'ClusterServicesEtcdDeprecatedBackupConfigArgs' backup_config: Backup options for etcd service. Just for Rancher v2.2.x (list maxitems:1)
        :param str ca_cert: TLS CA certificate for etcd service (string)
        :param str cert: TLS certificate for etcd service (string)
        :param str creation: Creation option for etcd service (string)
        :param Sequence[str] external_urls: External urls for etcd service (list)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param int gid: Etcd service GID. Default: `0`. For Rancher v2.3.x or above (int)
        :param str image: Docker image for scheduler service (string)
        :param str key: TLS key for etcd service (string)
        :param str path: Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param str retention: Retention for etcd backup. Default `6` (int)
        :param bool snapshot: Snapshot option for etcd service. Default `true` (bool)
        :param int uid: Etcd service UID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        ClusterServicesEtcdDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_config=backup_config,
            ca_cert=ca_cert,
            cert=cert,
            creation=creation,
            external_urls=external_urls,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            gid=gid,
            image=image,
            key=key,
            path=path,
            retention=retention,
            snapshot=snapshot,
            uid=uid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_config: Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfig'] = None,
             ca_cert: Optional[str] = None,
             cert: Optional[str] = None,
             creation: Optional[str] = None,
             external_urls: Optional[Sequence[str]] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             gid: Optional[int] = None,
             image: Optional[str] = None,
             key: Optional[str] = None,
             path: Optional[str] = None,
             retention: Optional[str] = None,
             snapshot: Optional[bool] = None,
             uid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_config is None and 'backupConfig' in kwargs:
            backup_config = kwargs['backupConfig']
        if ca_cert is None and 'caCert' in kwargs:
            ca_cert = kwargs['caCert']
        if external_urls is None and 'externalUrls' in kwargs:
            external_urls = kwargs['externalUrls']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if backup_config is not None:
            _setter("backup_config", backup_config)
        if ca_cert is not None:
            _setter("ca_cert", ca_cert)
        if cert is not None:
            _setter("cert", cert)
        if creation is not None:
            _setter("creation", creation)
        if external_urls is not None:
            _setter("external_urls", external_urls)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if gid is not None:
            _setter("gid", gid)
        if image is not None:
            _setter("image", image)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)
        if retention is not None:
            _setter("retention", retention)
        if snapshot is not None:
            _setter("snapshot", snapshot)
        if uid is not None:
            _setter("uid", uid)

    @property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfig']:
        """
        Backup options for etcd service. Just for Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "backup_config")

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        TLS CA certificate for etcd service (string)
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        TLS certificate for etcd service (string)
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def creation(self) -> Optional[str]:
        """
        Creation option for etcd service (string)
        """
        return pulumi.get(self, "creation")

    @property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[str]]:
        """
        External urls for etcd service (list)
        """
        return pulumi.get(self, "external_urls")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def gid(self) -> Optional[int]:
        """
        Etcd service GID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        return pulumi.get(self, "gid")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TLS key for etcd service (string)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def retention(self) -> Optional[str]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[bool]:
        """
        Snapshot option for etcd service. Default `true` (bool)
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter
    def uid(self) -> Optional[int]:
        """
        Etcd service UID. Default: `0`. For Rancher v2.3.x or above (int)
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterServicesEtcdDeprecatedBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"
        elif key == "s3BackupConfig":
            suggest = "s3_backup_config"
        elif key == "safeTimestamp":
            suggest = "safe_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcdDeprecatedBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcdDeprecatedBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcdDeprecatedBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 interval_hours: Optional[int] = None,
                 retention: Optional[int] = None,
                 s3_backup_config: Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig'] = None,
                 safe_timestamp: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param bool enabled: Enable secrets encryption (bool)
        :param int interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param int retention: Retention for etcd backup. Default `6` (int)
        :param 'ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfigArgs' s3_backup_config: S3 config options for etcd backup (list maxitems:1)
        :param bool safe_timestamp: Safe timestamp for etcd backup. Default: `false` (bool)
        :param int timeout: RKE node drain timeout (int)
        """
        ClusterServicesEtcdDeprecatedBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            interval_hours=interval_hours,
            retention=retention,
            s3_backup_config=s3_backup_config,
            safe_timestamp=safe_timestamp,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             interval_hours: Optional[int] = None,
             retention: Optional[int] = None,
             s3_backup_config: Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig'] = None,
             safe_timestamp: Optional[bool] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if interval_hours is None and 'intervalHours' in kwargs:
            interval_hours = kwargs['intervalHours']
        if s3_backup_config is None and 's3BackupConfig' in kwargs:
            s3_backup_config = kwargs['s3BackupConfig']
        if safe_timestamp is None and 'safeTimestamp' in kwargs:
            safe_timestamp = kwargs['safeTimestamp']

        if enabled is not None:
            _setter("enabled", enabled)
        if interval_hours is not None:
            _setter("interval_hours", interval_hours)
        if retention is not None:
            _setter("retention", retention)
        if s3_backup_config is not None:
            _setter("s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            _setter("safe_timestamp", safe_timestamp)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[int]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @property
    @pulumi.getter
    def retention(self) -> Optional[int]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig']:
        """
        S3 config options for etcd backup (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[bool]:
        """
        Safe timestamp for etcd backup. Default: `false` (bool)
        """
        return pulumi.get(self, "safe_timestamp")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        RKE node drain timeout (int)
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "customCa":
            suggest = "custom_ca"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_name: Optional[str] = None,
                 custom_ca: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 folder: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str access_key: Access key for S3 service (string)
        :param str bucket_name: Bucket name for S3 service (string)
        :param str custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param str endpoint: Endpoint for S3 service (string)
        :param str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param str region: Region for S3 service (string)
        :param str secret_key: Secret key for S3 service (string)
        """
        ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            bucket_name=bucket_name,
            custom_ca=custom_ca,
            endpoint=endpoint,
            folder=folder,
            region=region,
            secret_key=secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[str] = None,
             bucket_name: Optional[str] = None,
             custom_ca: Optional[str] = None,
             endpoint: Optional[str] = None,
             folder: Optional[str] = None,
             region: Optional[str] = None,
             secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_key is None and 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if custom_ca is None and 'customCa' in kwargs:
            custom_ca = kwargs['customCa']
        if secret_key is None and 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']

        if access_key is not None:
            _setter("access_key", access_key)
        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if custom_ca is not None:
            _setter("custom_ca", custom_ca)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if folder is not None:
            _setter("folder", folder)
        if region is not None:
            _setter("region", region)
        if secret_key is not None:
            _setter("secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for S3 service (string)
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[str]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def folder(self) -> Optional[str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for S3 service (string)
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ClusterServicesKubeApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysPullImages":
            suggest = "always_pull_images"
        elif key == "auditLog":
            suggest = "audit_log"
        elif key == "eventRateLimit":
            suggest = "event_rate_limit"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "podSecurityPolicy":
            suggest = "pod_security_policy"
        elif key == "secretsEncryptionConfig":
            suggest = "secrets_encryption_config"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"
        elif key == "serviceNodePortRange":
            suggest = "service_node_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_pull_images: Optional[bool] = None,
                 audit_log: Optional['outputs.ClusterServicesKubeApiAuditLog'] = None,
                 event_rate_limit: Optional['outputs.ClusterServicesKubeApiEventRateLimit'] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 pod_security_policy: Optional[bool] = None,
                 secrets_encryption_config: Optional['outputs.ClusterServicesKubeApiSecretsEncryptionConfig'] = None,
                 service_cluster_ip_range: Optional[str] = None,
                 service_node_port_range: Optional[str] = None):
        """
        :param bool always_pull_images: Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) (bool)
        :param 'ClusterServicesKubeApiAuditLogArgs' audit_log: K8s audit log configuration. (list maxitem: 1)
        :param 'ClusterServicesKubeApiEventRateLimitArgs' event_rate_limit: K8s event rate limit configuration. (list maxitem: 1)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        :param bool pod_security_policy: Pod Security Policy option for kube API service (bool)
        :param 'ClusterServicesKubeApiSecretsEncryptionConfigArgs' secrets_encryption_config: [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        :param str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        :param str service_node_port_range: Service Node Port Range option for kube API service (string)
        """
        ClusterServicesKubeApi._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_pull_images=always_pull_images,
            audit_log=audit_log,
            event_rate_limit=event_rate_limit,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
            pod_security_policy=pod_security_policy,
            secrets_encryption_config=secrets_encryption_config,
            service_cluster_ip_range=service_cluster_ip_range,
            service_node_port_range=service_node_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_pull_images: Optional[bool] = None,
             audit_log: Optional['outputs.ClusterServicesKubeApiAuditLog'] = None,
             event_rate_limit: Optional['outputs.ClusterServicesKubeApiEventRateLimit'] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             pod_security_policy: Optional[bool] = None,
             secrets_encryption_config: Optional['outputs.ClusterServicesKubeApiSecretsEncryptionConfig'] = None,
             service_cluster_ip_range: Optional[str] = None,
             service_node_port_range: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if always_pull_images is None and 'alwaysPullImages' in kwargs:
            always_pull_images = kwargs['alwaysPullImages']
        if audit_log is None and 'auditLog' in kwargs:
            audit_log = kwargs['auditLog']
        if event_rate_limit is None and 'eventRateLimit' in kwargs:
            event_rate_limit = kwargs['eventRateLimit']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if pod_security_policy is None and 'podSecurityPolicy' in kwargs:
            pod_security_policy = kwargs['podSecurityPolicy']
        if secrets_encryption_config is None and 'secretsEncryptionConfig' in kwargs:
            secrets_encryption_config = kwargs['secretsEncryptionConfig']
        if service_cluster_ip_range is None and 'serviceClusterIpRange' in kwargs:
            service_cluster_ip_range = kwargs['serviceClusterIpRange']
        if service_node_port_range is None and 'serviceNodePortRange' in kwargs:
            service_node_port_range = kwargs['serviceNodePortRange']

        if always_pull_images is not None:
            _setter("always_pull_images", always_pull_images)
        if audit_log is not None:
            _setter("audit_log", audit_log)
        if event_rate_limit is not None:
            _setter("event_rate_limit", event_rate_limit)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)
        if pod_security_policy is not None:
            _setter("pod_security_policy", pod_security_policy)
        if secrets_encryption_config is not None:
            _setter("secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            _setter("service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            _setter("service_node_port_range", service_node_port_range)

    @property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[bool]:
        """
        Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) (bool)
        """
        return pulumi.get(self, "always_pull_images")

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.ClusterServicesKubeApiAuditLog']:
        """
        K8s audit log configuration. (list maxitem: 1)
        """
        return pulumi.get(self, "audit_log")

    @property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.ClusterServicesKubeApiEventRateLimit']:
        """
        K8s event rate limit configuration. (list maxitem: 1)
        """
        return pulumi.get(self, "event_rate_limit")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="podSecurityPolicy")
    def pod_security_policy(self) -> Optional[bool]:
        """
        Pod Security Policy option for kube API service (bool)
        """
        return pulumi.get(self, "pod_security_policy")

    @property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.ClusterServicesKubeApiSecretsEncryptionConfig']:
        """
        [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        """
        return pulumi.get(self, "secrets_encryption_config")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[str]:
        """
        Service Node Port Range option for kube API service (string)
        """
        return pulumi.get(self, "service_node_port_range")


@pulumi.output_type
class ClusterServicesKubeApiAuditLog(dict):
    def __init__(__self__, *,
                 configuration: Optional['outputs.ClusterServicesKubeApiAuditLogConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        :param 'ClusterServicesKubeApiAuditLogConfigurationArgs' configuration: Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiAuditLog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.ClusterServicesKubeApiAuditLogConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ClusterServicesKubeApiAuditLogConfiguration']:
        """
        Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeApiAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxBackup":
            suggest = "max_backup"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApiAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: Optional[str] = None,
                 max_age: Optional[int] = None,
                 max_backup: Optional[int] = None,
                 max_size: Optional[int] = None,
                 path: Optional[str] = None,
                 policy: Optional[str] = None):
        """
        :param str format: Audit log format (string)
        :param int max_age: Audit log max age (int)
        :param int max_backup: Audit log max backup. Default: `10` (int)
        :param int max_size: Audit log max size. Default: `100` (int)
        :param str path: Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param str policy: Audit policy json encoded definition. `"apiVersion"` and `"kind":"Policy","rules"` fields are required in the json. Ex. `jsonencode({"apiVersion":"audit.k8s.io/v1","kind":"Policy","rules":[{"level":"RequestResponse","resources":[{"group":"","resources":["pods"]}]}]})` [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string)
        """
        ClusterServicesKubeApiAuditLogConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format=format,
            max_age=max_age,
            max_backup=max_backup,
            max_size=max_size,
            path=path,
            policy=policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format: Optional[str] = None,
             max_age: Optional[int] = None,
             max_backup: Optional[int] = None,
             max_size: Optional[int] = None,
             path: Optional[str] = None,
             policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_age is None and 'maxAge' in kwargs:
            max_age = kwargs['maxAge']
        if max_backup is None and 'maxBackup' in kwargs:
            max_backup = kwargs['maxBackup']
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']

        if format is not None:
            _setter("format", format)
        if max_age is not None:
            _setter("max_age", max_age)
        if max_backup is not None:
            _setter("max_backup", max_backup)
        if max_size is not None:
            _setter("max_size", max_size)
        if path is not None:
            _setter("path", path)
        if policy is not None:
            _setter("policy", policy)

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Audit log format (string)
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Audit log max age (int)
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[int]:
        """
        Audit log max backup. Default: `10` (int)
        """
        return pulumi.get(self, "max_backup")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        Audit log max size. Default: `100` (int)
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Audit policy json encoded definition. `"apiVersion"` and `"kind":"Policy","rules"` fields are required in the json. Ex. `jsonencode({"apiVersion":"audit.k8s.io/v1","kind":"Policy","rules":[{"level":"RequestResponse","resources":[{"group":"","resources":["pods"]}]}]})` [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string)
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class ClusterServicesKubeApiDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysPullImages":
            suggest = "always_pull_images"
        elif key == "auditLog":
            suggest = "audit_log"
        elif key == "eventRateLimit":
            suggest = "event_rate_limit"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "podSecurityPolicy":
            suggest = "pod_security_policy"
        elif key == "secretsEncryptionConfig":
            suggest = "secrets_encryption_config"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"
        elif key == "serviceNodePortRange":
            suggest = "service_node_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApiDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApiDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApiDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_pull_images: Optional[bool] = None,
                 audit_log: Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLog'] = None,
                 event_rate_limit: Optional['outputs.ClusterServicesKubeApiDeprecatedEventRateLimit'] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 pod_security_policy: Optional[bool] = None,
                 secrets_encryption_config: Optional['outputs.ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig'] = None,
                 service_cluster_ip_range: Optional[str] = None,
                 service_node_port_range: Optional[str] = None):
        """
        :param bool always_pull_images: Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) (bool)
        :param 'ClusterServicesKubeApiDeprecatedAuditLogArgs' audit_log: K8s audit log configuration. (list maxitem: 1)
        :param 'ClusterServicesKubeApiDeprecatedEventRateLimitArgs' event_rate_limit: K8s event rate limit configuration. (list maxitem: 1)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        :param bool pod_security_policy: Pod Security Policy option for kube API service (bool)
        :param 'ClusterServicesKubeApiDeprecatedSecretsEncryptionConfigArgs' secrets_encryption_config: [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        :param str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        :param str service_node_port_range: Service Node Port Range option for kube API service (string)
        """
        ClusterServicesKubeApiDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_pull_images=always_pull_images,
            audit_log=audit_log,
            event_rate_limit=event_rate_limit,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
            pod_security_policy=pod_security_policy,
            secrets_encryption_config=secrets_encryption_config,
            service_cluster_ip_range=service_cluster_ip_range,
            service_node_port_range=service_node_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_pull_images: Optional[bool] = None,
             audit_log: Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLog'] = None,
             event_rate_limit: Optional['outputs.ClusterServicesKubeApiDeprecatedEventRateLimit'] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             pod_security_policy: Optional[bool] = None,
             secrets_encryption_config: Optional['outputs.ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig'] = None,
             service_cluster_ip_range: Optional[str] = None,
             service_node_port_range: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if always_pull_images is None and 'alwaysPullImages' in kwargs:
            always_pull_images = kwargs['alwaysPullImages']
        if audit_log is None and 'auditLog' in kwargs:
            audit_log = kwargs['auditLog']
        if event_rate_limit is None and 'eventRateLimit' in kwargs:
            event_rate_limit = kwargs['eventRateLimit']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if pod_security_policy is None and 'podSecurityPolicy' in kwargs:
            pod_security_policy = kwargs['podSecurityPolicy']
        if secrets_encryption_config is None and 'secretsEncryptionConfig' in kwargs:
            secrets_encryption_config = kwargs['secretsEncryptionConfig']
        if service_cluster_ip_range is None and 'serviceClusterIpRange' in kwargs:
            service_cluster_ip_range = kwargs['serviceClusterIpRange']
        if service_node_port_range is None and 'serviceNodePortRange' in kwargs:
            service_node_port_range = kwargs['serviceNodePortRange']

        if always_pull_images is not None:
            _setter("always_pull_images", always_pull_images)
        if audit_log is not None:
            _setter("audit_log", audit_log)
        if event_rate_limit is not None:
            _setter("event_rate_limit", event_rate_limit)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)
        if pod_security_policy is not None:
            _setter("pod_security_policy", pod_security_policy)
        if secrets_encryption_config is not None:
            _setter("secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            _setter("service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            _setter("service_node_port_range", service_node_port_range)

    @property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[bool]:
        """
        Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) (bool)
        """
        return pulumi.get(self, "always_pull_images")

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLog']:
        """
        K8s audit log configuration. (list maxitem: 1)
        """
        return pulumi.get(self, "audit_log")

    @property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.ClusterServicesKubeApiDeprecatedEventRateLimit']:
        """
        K8s event rate limit configuration. (list maxitem: 1)
        """
        return pulumi.get(self, "event_rate_limit")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="podSecurityPolicy")
    def pod_security_policy(self) -> Optional[bool]:
        """
        Pod Security Policy option for kube API service (bool)
        """
        return pulumi.get(self, "pod_security_policy")

    @property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig']:
        """
        [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        """
        return pulumi.get(self, "secrets_encryption_config")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[str]:
        """
        Service Node Port Range option for kube API service (string)
        """
        return pulumi.get(self, "service_node_port_range")


@pulumi.output_type
class ClusterServicesKubeApiDeprecatedAuditLog(dict):
    def __init__(__self__, *,
                 configuration: Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLogConfiguration'] = None,
                 enabled: Optional[bool] = None):
        """
        :param 'ClusterServicesKubeApiDeprecatedAuditLogConfigurationArgs' configuration: Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiDeprecatedAuditLog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLogConfiguration'] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ClusterServicesKubeApiDeprecatedAuditLogConfiguration']:
        """
        Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeApiDeprecatedAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxBackup":
            suggest = "max_backup"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApiDeprecatedAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApiDeprecatedAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApiDeprecatedAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: Optional[str] = None,
                 max_age: Optional[int] = None,
                 max_backup: Optional[int] = None,
                 max_size: Optional[int] = None,
                 path: Optional[str] = None,
                 policy: Optional[str] = None):
        """
        :param str format: Audit log format (string)
        :param int max_age: Audit log max age (int)
        :param int max_backup: Audit log max backup. Default: `10` (int)
        :param int max_size: Audit log max size. Default: `100` (int)
        :param str path: Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param str policy: Audit policy json encoded definition. `"apiVersion"` and `"kind":"Policy","rules"` fields are required in the json. Ex. `jsonencode({"apiVersion":"audit.k8s.io/v1","kind":"Policy","rules":[{"level":"RequestResponse","resources":[{"group":"","resources":["pods"]}]}]})` [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string)
        """
        ClusterServicesKubeApiDeprecatedAuditLogConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format=format,
            max_age=max_age,
            max_backup=max_backup,
            max_size=max_size,
            path=path,
            policy=policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format: Optional[str] = None,
             max_age: Optional[int] = None,
             max_backup: Optional[int] = None,
             max_size: Optional[int] = None,
             path: Optional[str] = None,
             policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_age is None and 'maxAge' in kwargs:
            max_age = kwargs['maxAge']
        if max_backup is None and 'maxBackup' in kwargs:
            max_backup = kwargs['maxBackup']
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']

        if format is not None:
            _setter("format", format)
        if max_age is not None:
            _setter("max_age", max_age)
        if max_backup is not None:
            _setter("max_backup", max_backup)
        if max_size is not None:
            _setter("max_size", max_size)
        if path is not None:
            _setter("path", path)
        if policy is not None:
            _setter("policy", policy)

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Audit log format (string)
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Audit log max age (int)
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[int]:
        """
        Audit log max backup. Default: `10` (int)
        """
        return pulumi.get(self, "max_backup")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        Audit log max size. Default: `100` (int)
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Audit policy json encoded definition. `"apiVersion"` and `"kind":"Policy","rules"` fields are required in the json. Ex. `jsonencode({"apiVersion":"audit.k8s.io/v1","kind":"Policy","rules":[{"level":"RequestResponse","resources":[{"group":"","resources":["pods"]}]}]})` [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string)
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class ClusterServicesKubeApiDeprecatedEventRateLimit(dict):
    def __init__(__self__, *,
                 configuration: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str configuration: Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiDeprecatedEventRateLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[str]:
        """
        Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConfig":
            suggest = "custom_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_config: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str custom_config: Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. Ex. `apiVersion: apiserver.config.k8s.io/v1\\nkind: EncryptionConfiguration\\nresources:\\n- resources:\\n  - secrets\\n  providers:\\n  - aescbc:\\n      keys:\\n      - name: k-fw5hn\\n        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=\\n    identity: {}\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_config=custom_config,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_config: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_config is None and 'customConfig' in kwargs:
            custom_config = kwargs['customConfig']

        if custom_config is not None:
            _setter("custom_config", custom_config)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[str]:
        """
        Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. Ex. `apiVersion: apiserver.config.k8s.io/v1\\nkind: EncryptionConfiguration\\nresources:\\n- resources:\\n  - secrets\\n  providers:\\n  - aescbc:\\n      keys:\\n      - name: k-fw5hn\\n        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=\\n    identity: {}\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string)
        """
        return pulumi.get(self, "custom_config")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeApiEventRateLimit(dict):
    def __init__(__self__, *,
                 configuration: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str configuration: Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiEventRateLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration=configuration,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if configuration is not None:
            _setter("configuration", configuration)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[str]:
        """
        Event rate limit yaml encoded configuration. `"apiVersion"` and `"kind":"Configuration"` fields are required in the yaml. Ex. `apiVersion: eventratelimit.admission.k8s.io/v1alpha1\\nkind: Configuration\\nlimits:\\n- type: Server\\n  burst: 30000\\n  qps: 6000\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string)
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeApiSecretsEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConfig":
            suggest = "custom_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeApiSecretsEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_config: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str custom_config: Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. Ex. `apiVersion: apiserver.config.k8s.io/v1\\nkind: EncryptionConfiguration\\nresources:\\n- resources:\\n  - secrets\\n  providers:\\n  - aescbc:\\n      keys:\\n      - name: k-fw5hn\\n        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=\\n    identity: {}\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string)
        :param bool enabled: Enable secrets encryption (bool)
        """
        ClusterServicesKubeApiSecretsEncryptionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_config=custom_config,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_config: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_config is None and 'customConfig' in kwargs:
            custom_config = kwargs['customConfig']

        if custom_config is not None:
            _setter("custom_config", custom_config)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[str]:
        """
        Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. Ex. `apiVersion: apiserver.config.k8s.io/v1\\nkind: EncryptionConfiguration\\nresources:\\n- resources:\\n  - secrets\\n  providers:\\n  - aescbc:\\n      keys:\\n      - name: k-fw5hn\\n        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=\\n    identity: {}\\n` [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string)
        """
        return pulumi.get(self, "custom_config")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable secrets encryption (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServicesKubeController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_cidr: Optional[str] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 service_cluster_ip_range: Optional[str] = None):
        """
        :param str cluster_cidr: Cluster CIDR option for kube controller service (string)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        :param str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        """
        ClusterServicesKubeController._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_cidr=cluster_cidr,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
            service_cluster_ip_range=service_cluster_ip_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_cidr: Optional[str] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             service_cluster_ip_range: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster_cidr is None and 'clusterCidr' in kwargs:
            cluster_cidr = kwargs['clusterCidr']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if service_cluster_ip_range is None and 'serviceClusterIpRange' in kwargs:
            service_cluster_ip_range = kwargs['serviceClusterIpRange']

        if cluster_cidr is not None:
            _setter("cluster_cidr", cluster_cidr)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)
        if service_cluster_ip_range is not None:
            _setter("service_cluster_ip_range", service_cluster_ip_range)

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[str]:
        """
        Cluster CIDR option for kube controller service (string)
        """
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")


@pulumi.output_type
class ClusterServicesKubeControllerDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeControllerDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeControllerDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeControllerDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_cidr: Optional[str] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 service_cluster_ip_range: Optional[str] = None):
        """
        :param str cluster_cidr: Cluster CIDR option for kube controller service (string)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        :param str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        """
        ClusterServicesKubeControllerDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_cidr=cluster_cidr,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
            service_cluster_ip_range=service_cluster_ip_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_cidr: Optional[str] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             service_cluster_ip_range: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster_cidr is None and 'clusterCidr' in kwargs:
            cluster_cidr = kwargs['clusterCidr']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if service_cluster_ip_range is None and 'serviceClusterIpRange' in kwargs:
            service_cluster_ip_range = kwargs['serviceClusterIpRange']

        if cluster_cidr is not None:
            _setter("cluster_cidr", cluster_cidr)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)
        if service_cluster_ip_range is not None:
            _setter("service_cluster_ip_range", service_cluster_ip_range)

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[str]:
        """
        Cluster CIDR option for kube controller service (string)
        """
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")


@pulumi.output_type
class ClusterServicesKubeProxyDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeProxyDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeProxyDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeProxyDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None):
        """
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        """
        ClusterServicesKubeProxyDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterServicesKubeSchedulerDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeSchedulerDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeSchedulerDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeSchedulerDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None):
        """
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        """
        ClusterServicesKubeSchedulerDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterServicesKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterDnsServer":
            suggest = "cluster_dns_server"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "generateServingCertificate":
            suggest = "generate_serving_certificate"
        elif key == "infraContainerImage":
            suggest = "infra_container_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_dns_server: Optional[str] = None,
                 cluster_domain: Optional[str] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 fail_swap_on: Optional[bool] = None,
                 generate_serving_certificate: Optional[bool] = None,
                 image: Optional[str] = None,
                 infra_container_image: Optional[str] = None):
        """
        :param str cluster_dns_server: Cluster DNS Server option for kubelet service (string)
        :param str cluster_domain: Cluster Domain option for kubelet service. Default `cluster.local` (string)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param bool fail_swap_on: Enable or disable failing when swap on is not supported (bool)
        :param bool generate_serving_certificate: [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        :param str image: Docker image for scheduler service (string)
        :param str infra_container_image: Infra container image for kubelet service (string)
        """
        ClusterServicesKubelet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_dns_server=cluster_dns_server,
            cluster_domain=cluster_domain,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            fail_swap_on=fail_swap_on,
            generate_serving_certificate=generate_serving_certificate,
            image=image,
            infra_container_image=infra_container_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_dns_server: Optional[str] = None,
             cluster_domain: Optional[str] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             fail_swap_on: Optional[bool] = None,
             generate_serving_certificate: Optional[bool] = None,
             image: Optional[str] = None,
             infra_container_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster_dns_server is None and 'clusterDnsServer' in kwargs:
            cluster_dns_server = kwargs['clusterDnsServer']
        if cluster_domain is None and 'clusterDomain' in kwargs:
            cluster_domain = kwargs['clusterDomain']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if fail_swap_on is None and 'failSwapOn' in kwargs:
            fail_swap_on = kwargs['failSwapOn']
        if generate_serving_certificate is None and 'generateServingCertificate' in kwargs:
            generate_serving_certificate = kwargs['generateServingCertificate']
        if infra_container_image is None and 'infraContainerImage' in kwargs:
            infra_container_image = kwargs['infraContainerImage']

        if cluster_dns_server is not None:
            _setter("cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            _setter("cluster_domain", cluster_domain)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if fail_swap_on is not None:
            _setter("fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            _setter("generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            _setter("image", image)
        if infra_container_image is not None:
            _setter("infra_container_image", infra_container_image)

    @property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[str]:
        """
        Cluster DNS Server option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_dns_server")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[str]:
        """
        Cluster Domain option for kubelet service. Default `cluster.local` (string)
        """
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[bool]:
        """
        Enable or disable failing when swap on is not supported (bool)
        """
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[bool]:
        """
        [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        """
        return pulumi.get(self, "generate_serving_certificate")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[str]:
        """
        Infra container image for kubelet service (string)
        """
        return pulumi.get(self, "infra_container_image")


@pulumi.output_type
class ClusterServicesKubeletDeprecated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterDnsServer":
            suggest = "cluster_dns_server"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "generateServingCertificate":
            suggest = "generate_serving_certificate"
        elif key == "infraContainerImage":
            suggest = "infra_container_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeletDeprecated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeletDeprecated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeletDeprecated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_dns_server: Optional[str] = None,
                 cluster_domain: Optional[str] = None,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 fail_swap_on: Optional[bool] = None,
                 generate_serving_certificate: Optional[bool] = None,
                 image: Optional[str] = None,
                 infra_container_image: Optional[str] = None):
        """
        :param str cluster_dns_server: Cluster DNS Server option for kubelet service (string)
        :param str cluster_domain: Cluster Domain option for kubelet service. Default `cluster.local` (string)
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param bool fail_swap_on: Enable or disable failing when swap on is not supported (bool)
        :param bool generate_serving_certificate: [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        :param str image: Docker image for scheduler service (string)
        :param str infra_container_image: Infra container image for kubelet service (string)
        """
        ClusterServicesKubeletDeprecated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_dns_server=cluster_dns_server,
            cluster_domain=cluster_domain,
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            fail_swap_on=fail_swap_on,
            generate_serving_certificate=generate_serving_certificate,
            image=image,
            infra_container_image=infra_container_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_dns_server: Optional[str] = None,
             cluster_domain: Optional[str] = None,
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             fail_swap_on: Optional[bool] = None,
             generate_serving_certificate: Optional[bool] = None,
             image: Optional[str] = None,
             infra_container_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster_dns_server is None and 'clusterDnsServer' in kwargs:
            cluster_dns_server = kwargs['clusterDnsServer']
        if cluster_domain is None and 'clusterDomain' in kwargs:
            cluster_domain = kwargs['clusterDomain']
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']
        if fail_swap_on is None and 'failSwapOn' in kwargs:
            fail_swap_on = kwargs['failSwapOn']
        if generate_serving_certificate is None and 'generateServingCertificate' in kwargs:
            generate_serving_certificate = kwargs['generateServingCertificate']
        if infra_container_image is None and 'infraContainerImage' in kwargs:
            infra_container_image = kwargs['infraContainerImage']

        if cluster_dns_server is not None:
            _setter("cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            _setter("cluster_domain", cluster_domain)
        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if fail_swap_on is not None:
            _setter("fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            _setter("generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            _setter("image", image)
        if infra_container_image is not None:
            _setter("infra_container_image", infra_container_image)

    @property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[str]:
        """
        Cluster DNS Server option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_dns_server")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[str]:
        """
        Cluster Domain option for kubelet service. Default `cluster.local` (string)
        """
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[bool]:
        """
        Enable or disable failing when swap on is not supported (bool)
        """
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[bool]:
        """
        [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        """
        return pulumi.get(self, "generate_serving_certificate")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[str]:
        """
        Infra container image for kubelet service (string)
        """
        return pulumi.get(self, "infra_container_image")


@pulumi.output_type
class ClusterServicesKubeproxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesKubeproxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesKubeproxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesKubeproxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None):
        """
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        """
        ClusterServicesKubeproxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterServicesScheduler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServicesScheduler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServicesScheduler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServicesScheduler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, Any]] = None,
                 extra_binds: Optional[Sequence[str]] = None,
                 extra_envs: Optional[Sequence[str]] = None,
                 image: Optional[str] = None):
        """
        :param Mapping[str, Any] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[str] extra_envs: Extra environment for scheduler service (list)
        :param str image: Docker image for scheduler service (string)
        """
        ClusterServicesScheduler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            extra_args=extra_args,
            extra_binds=extra_binds,
            extra_envs=extra_envs,
            image=image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             extra_args: Optional[Mapping[str, Any]] = None,
             extra_binds: Optional[Sequence[str]] = None,
             extra_envs: Optional[Sequence[str]] = None,
             image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extra_args is None and 'extraArgs' in kwargs:
            extra_args = kwargs['extraArgs']
        if extra_binds is None and 'extraBinds' in kwargs:
            extra_binds = kwargs['extraBinds']
        if extra_envs is None and 'extraEnvs' in kwargs:
            extra_envs = kwargs['extraEnvs']

        if extra_args is not None:
            _setter("extra_args", extra_args)
        if extra_binds is not None:
            _setter("extra_binds", extra_binds)
        if extra_envs is not None:
            _setter("extra_envs", extra_envs)
        if image is not None:
            _setter("image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, Any]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterSystemImages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciCniDeployContainer":
            suggest = "aci_cni_deploy_container"
        elif key == "aciControllerContainer":
            suggest = "aci_controller_container"
        elif key == "aciHostContainer":
            suggest = "aci_host_container"
        elif key == "aciMcastContainer":
            suggest = "aci_mcast_container"
        elif key == "aciOpflexContainer":
            suggest = "aci_opflex_container"
        elif key == "aciOvsContainer":
            suggest = "aci_ovs_container"
        elif key == "calicoCni":
            suggest = "calico_cni"
        elif key == "calicoControllers":
            suggest = "calico_controllers"
        elif key == "calicoCtl":
            suggest = "calico_ctl"
        elif key == "calicoFlexVol":
            suggest = "calico_flex_vol"
        elif key == "calicoNode":
            suggest = "calico_node"
        elif key == "canalCni":
            suggest = "canal_cni"
        elif key == "canalFlannel":
            suggest = "canal_flannel"
        elif key == "canalFlexVol":
            suggest = "canal_flex_vol"
        elif key == "canalNode":
            suggest = "canal_node"
        elif key == "certDownloader":
            suggest = "cert_downloader"
        elif key == "corednsAutoscaler":
            suggest = "coredns_autoscaler"
        elif key == "flannelCni":
            suggest = "flannel_cni"
        elif key == "ingressBackend":
            suggest = "ingress_backend"
        elif key == "kubeDns":
            suggest = "kube_dns"
        elif key == "kubeDnsAutoscaler":
            suggest = "kube_dns_autoscaler"
        elif key == "kubeDnsSidecar":
            suggest = "kube_dns_sidecar"
        elif key == "kubernetesServicesSidecar":
            suggest = "kubernetes_services_sidecar"
        elif key == "metricsServer":
            suggest = "metrics_server"
        elif key == "nginxProxy":
            suggest = "nginx_proxy"
        elif key == "podInfraContainer":
            suggest = "pod_infra_container"
        elif key == "weaveCni":
            suggest = "weave_cni"
        elif key == "weaveNode":
            suggest = "weave_node"
        elif key == "windowsPodInfraContainer":
            suggest = "windows_pod_infra_container"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSystemImages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSystemImages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSystemImages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_cni_deploy_container: Optional[str] = None,
                 aci_controller_container: Optional[str] = None,
                 aci_host_container: Optional[str] = None,
                 aci_mcast_container: Optional[str] = None,
                 aci_opflex_container: Optional[str] = None,
                 aci_ovs_container: Optional[str] = None,
                 alpine: Optional[str] = None,
                 calico_cni: Optional[str] = None,
                 calico_controllers: Optional[str] = None,
                 calico_ctl: Optional[str] = None,
                 calico_flex_vol: Optional[str] = None,
                 calico_node: Optional[str] = None,
                 canal_cni: Optional[str] = None,
                 canal_flannel: Optional[str] = None,
                 canal_flex_vol: Optional[str] = None,
                 canal_node: Optional[str] = None,
                 cert_downloader: Optional[str] = None,
                 coredns: Optional[str] = None,
                 coredns_autoscaler: Optional[str] = None,
                 dnsmasq: Optional[str] = None,
                 etcd: Optional[str] = None,
                 flannel: Optional[str] = None,
                 flannel_cni: Optional[str] = None,
                 ingress: Optional[str] = None,
                 ingress_backend: Optional[str] = None,
                 kube_dns: Optional[str] = None,
                 kube_dns_autoscaler: Optional[str] = None,
                 kube_dns_sidecar: Optional[str] = None,
                 kubernetes: Optional[str] = None,
                 kubernetes_services_sidecar: Optional[str] = None,
                 metrics_server: Optional[str] = None,
                 nginx_proxy: Optional[str] = None,
                 nodelocal: Optional[str] = None,
                 pod_infra_container: Optional[str] = None,
                 weave_cni: Optional[str] = None,
                 weave_node: Optional[str] = None,
                 windows_pod_infra_container: Optional[str] = None):
        """
        :param str aci_cni_deploy_container: Docker image for aci_cni_deploy_container (string)
        :param str aci_controller_container: Docker image for aci_controller_container (string)
        :param str aci_host_container: Docker image for aci_host_container (string)
        :param str aci_mcast_container: Docker image for aci_mcast_container (string)
        :param str aci_opflex_container: Docker image for aci_opflex_container (string)
        :param str aci_ovs_container: Docker image for aci_ovs_container (string)
        :param str alpine: Docker image for alpine (string)
        :param str calico_cni: Docker image for calico_cni (string)
        :param str calico_controllers: Docker image for calico_controllers (string)
        :param str calico_ctl: Docker image for calico_ctl (string)
        :param str calico_flex_vol: Docker image for calico_flex_vol (string)
        :param str calico_node: Docker image for calico_node (string)
        :param str canal_cni: Docker image for canal_cni (string)
        :param str canal_flannel: Docker image for canal_flannel (string)
        :param str canal_flex_vol: Docker image for canal_flex_vol (string)
        :param str canal_node: Docker image for canal_node (string)
        :param str cert_downloader: Docker image for cert_downloader (string)
        :param str coredns: Docker image for coredns (string)
        :param str coredns_autoscaler: Docker image for coredns_autoscaler (string)
        :param str dnsmasq: Docker image for dnsmasq (string)
        :param str etcd: Docker image for etcd (string)
        :param str flannel: Docker image for flannel (string)
        :param str flannel_cni: Docker image for flannel_cni (string)
        :param str ingress: RKE k8s cluster ingress controller configuration (list maxitems:1)
        :param str ingress_backend: Docker image for ingress_backend (string)
        :param str kube_dns: Docker image for kube_dns (string)
        :param str kube_dns_autoscaler: Docker image for kube_dns_autoscaler (string)
        :param str kube_dns_sidecar: Docker image for kube_dns_sidecar (string)
        :param str kubernetes: Docker image for kubernetes (string)
        :param str kubernetes_services_sidecar: Docker image for kubernetes_services_sidecar (string)
        :param str metrics_server: Docker image for metrics_server (string)
        :param str nginx_proxy: Docker image for nginx_proxy (string)
        :param str nodelocal: Docker image for nodelocal (string)
        :param str pod_infra_container: Docker image for pod_infra_container (string)
        :param str weave_cni: Docker image for weave_cni (string)
        :param str weave_node: Docker image for weave_node (string)
        :param str windows_pod_infra_container: Docker image for windows_pod_infra_container (string)
        """
        ClusterSystemImages._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aci_cni_deploy_container=aci_cni_deploy_container,
            aci_controller_container=aci_controller_container,
            aci_host_container=aci_host_container,
            aci_mcast_container=aci_mcast_container,
            aci_opflex_container=aci_opflex_container,
            aci_ovs_container=aci_ovs_container,
            alpine=alpine,
            calico_cni=calico_cni,
            calico_controllers=calico_controllers,
            calico_ctl=calico_ctl,
            calico_flex_vol=calico_flex_vol,
            calico_node=calico_node,
            canal_cni=canal_cni,
            canal_flannel=canal_flannel,
            canal_flex_vol=canal_flex_vol,
            canal_node=canal_node,
            cert_downloader=cert_downloader,
            coredns=coredns,
            coredns_autoscaler=coredns_autoscaler,
            dnsmasq=dnsmasq,
            etcd=etcd,
            flannel=flannel,
            flannel_cni=flannel_cni,
            ingress=ingress,
            ingress_backend=ingress_backend,
            kube_dns=kube_dns,
            kube_dns_autoscaler=kube_dns_autoscaler,
            kube_dns_sidecar=kube_dns_sidecar,
            kubernetes=kubernetes,
            kubernetes_services_sidecar=kubernetes_services_sidecar,
            metrics_server=metrics_server,
            nginx_proxy=nginx_proxy,
            nodelocal=nodelocal,
            pod_infra_container=pod_infra_container,
            weave_cni=weave_cni,
            weave_node=weave_node,
            windows_pod_infra_container=windows_pod_infra_container,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aci_cni_deploy_container: Optional[str] = None,
             aci_controller_container: Optional[str] = None,
             aci_host_container: Optional[str] = None,
             aci_mcast_container: Optional[str] = None,
             aci_opflex_container: Optional[str] = None,
             aci_ovs_container: Optional[str] = None,
             alpine: Optional[str] = None,
             calico_cni: Optional[str] = None,
             calico_controllers: Optional[str] = None,
             calico_ctl: Optional[str] = None,
             calico_flex_vol: Optional[str] = None,
             calico_node: Optional[str] = None,
             canal_cni: Optional[str] = None,
             canal_flannel: Optional[str] = None,
             canal_flex_vol: Optional[str] = None,
             canal_node: Optional[str] = None,
             cert_downloader: Optional[str] = None,
             coredns: Optional[str] = None,
             coredns_autoscaler: Optional[str] = None,
             dnsmasq: Optional[str] = None,
             etcd: Optional[str] = None,
             flannel: Optional[str] = None,
             flannel_cni: Optional[str] = None,
             ingress: Optional[str] = None,
             ingress_backend: Optional[str] = None,
             kube_dns: Optional[str] = None,
             kube_dns_autoscaler: Optional[str] = None,
             kube_dns_sidecar: Optional[str] = None,
             kubernetes: Optional[str] = None,
             kubernetes_services_sidecar: Optional[str] = None,
             metrics_server: Optional[str] = None,
             nginx_proxy: Optional[str] = None,
             nodelocal: Optional[str] = None,
             pod_infra_container: Optional[str] = None,
             weave_cni: Optional[str] = None,
             weave_node: Optional[str] = None,
             windows_pod_infra_container: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aci_cni_deploy_container is None and 'aciCniDeployContainer' in kwargs:
            aci_cni_deploy_container = kwargs['aciCniDeployContainer']
        if aci_controller_container is None and 'aciControllerContainer' in kwargs:
            aci_controller_container = kwargs['aciControllerContainer']
        if aci_host_container is None and 'aciHostContainer' in kwargs:
            aci_host_container = kwargs['aciHostContainer']
        if aci_mcast_container is None and 'aciMcastContainer' in kwargs:
            aci_mcast_container = kwargs['aciMcastContainer']
        if aci_opflex_container is None and 'aciOpflexContainer' in kwargs:
            aci_opflex_container = kwargs['aciOpflexContainer']
        if aci_ovs_container is None and 'aciOvsContainer' in kwargs:
            aci_ovs_container = kwargs['aciOvsContainer']
        if calico_cni is None and 'calicoCni' in kwargs:
            calico_cni = kwargs['calicoCni']
        if calico_controllers is None and 'calicoControllers' in kwargs:
            calico_controllers = kwargs['calicoControllers']
        if calico_ctl is None and 'calicoCtl' in kwargs:
            calico_ctl = kwargs['calicoCtl']
        if calico_flex_vol is None and 'calicoFlexVol' in kwargs:
            calico_flex_vol = kwargs['calicoFlexVol']
        if calico_node is None and 'calicoNode' in kwargs:
            calico_node = kwargs['calicoNode']
        if canal_cni is None and 'canalCni' in kwargs:
            canal_cni = kwargs['canalCni']
        if canal_flannel is None and 'canalFlannel' in kwargs:
            canal_flannel = kwargs['canalFlannel']
        if canal_flex_vol is None and 'canalFlexVol' in kwargs:
            canal_flex_vol = kwargs['canalFlexVol']
        if canal_node is None and 'canalNode' in kwargs:
            canal_node = kwargs['canalNode']
        if cert_downloader is None and 'certDownloader' in kwargs:
            cert_downloader = kwargs['certDownloader']
        if coredns_autoscaler is None and 'corednsAutoscaler' in kwargs:
            coredns_autoscaler = kwargs['corednsAutoscaler']
        if flannel_cni is None and 'flannelCni' in kwargs:
            flannel_cni = kwargs['flannelCni']
        if ingress_backend is None and 'ingressBackend' in kwargs:
            ingress_backend = kwargs['ingressBackend']
        if kube_dns is None and 'kubeDns' in kwargs:
            kube_dns = kwargs['kubeDns']
        if kube_dns_autoscaler is None and 'kubeDnsAutoscaler' in kwargs:
            kube_dns_autoscaler = kwargs['kubeDnsAutoscaler']
        if kube_dns_sidecar is None and 'kubeDnsSidecar' in kwargs:
            kube_dns_sidecar = kwargs['kubeDnsSidecar']
        if kubernetes_services_sidecar is None and 'kubernetesServicesSidecar' in kwargs:
            kubernetes_services_sidecar = kwargs['kubernetesServicesSidecar']
        if metrics_server is None and 'metricsServer' in kwargs:
            metrics_server = kwargs['metricsServer']
        if nginx_proxy is None and 'nginxProxy' in kwargs:
            nginx_proxy = kwargs['nginxProxy']
        if pod_infra_container is None and 'podInfraContainer' in kwargs:
            pod_infra_container = kwargs['podInfraContainer']
        if weave_cni is None and 'weaveCni' in kwargs:
            weave_cni = kwargs['weaveCni']
        if weave_node is None and 'weaveNode' in kwargs:
            weave_node = kwargs['weaveNode']
        if windows_pod_infra_container is None and 'windowsPodInfraContainer' in kwargs:
            windows_pod_infra_container = kwargs['windowsPodInfraContainer']

        if aci_cni_deploy_container is not None:
            _setter("aci_cni_deploy_container", aci_cni_deploy_container)
        if aci_controller_container is not None:
            _setter("aci_controller_container", aci_controller_container)
        if aci_host_container is not None:
            _setter("aci_host_container", aci_host_container)
        if aci_mcast_container is not None:
            _setter("aci_mcast_container", aci_mcast_container)
        if aci_opflex_container is not None:
            _setter("aci_opflex_container", aci_opflex_container)
        if aci_ovs_container is not None:
            _setter("aci_ovs_container", aci_ovs_container)
        if alpine is not None:
            _setter("alpine", alpine)
        if calico_cni is not None:
            _setter("calico_cni", calico_cni)
        if calico_controllers is not None:
            _setter("calico_controllers", calico_controllers)
        if calico_ctl is not None:
            _setter("calico_ctl", calico_ctl)
        if calico_flex_vol is not None:
            _setter("calico_flex_vol", calico_flex_vol)
        if calico_node is not None:
            _setter("calico_node", calico_node)
        if canal_cni is not None:
            _setter("canal_cni", canal_cni)
        if canal_flannel is not None:
            _setter("canal_flannel", canal_flannel)
        if canal_flex_vol is not None:
            _setter("canal_flex_vol", canal_flex_vol)
        if canal_node is not None:
            _setter("canal_node", canal_node)
        if cert_downloader is not None:
            _setter("cert_downloader", cert_downloader)
        if coredns is not None:
            _setter("coredns", coredns)
        if coredns_autoscaler is not None:
            _setter("coredns_autoscaler", coredns_autoscaler)
        if dnsmasq is not None:
            _setter("dnsmasq", dnsmasq)
        if etcd is not None:
            _setter("etcd", etcd)
        if flannel is not None:
            _setter("flannel", flannel)
        if flannel_cni is not None:
            _setter("flannel_cni", flannel_cni)
        if ingress is not None:
            _setter("ingress", ingress)
        if ingress_backend is not None:
            _setter("ingress_backend", ingress_backend)
        if kube_dns is not None:
            _setter("kube_dns", kube_dns)
        if kube_dns_autoscaler is not None:
            _setter("kube_dns_autoscaler", kube_dns_autoscaler)
        if kube_dns_sidecar is not None:
            _setter("kube_dns_sidecar", kube_dns_sidecar)
        if kubernetes is not None:
            _setter("kubernetes", kubernetes)
        if kubernetes_services_sidecar is not None:
            _setter("kubernetes_services_sidecar", kubernetes_services_sidecar)
        if metrics_server is not None:
            _setter("metrics_server", metrics_server)
        if nginx_proxy is not None:
            _setter("nginx_proxy", nginx_proxy)
        if nodelocal is not None:
            _setter("nodelocal", nodelocal)
        if pod_infra_container is not None:
            _setter("pod_infra_container", pod_infra_container)
        if weave_cni is not None:
            _setter("weave_cni", weave_cni)
        if weave_node is not None:
            _setter("weave_node", weave_node)
        if windows_pod_infra_container is not None:
            _setter("windows_pod_infra_container", windows_pod_infra_container)

    @property
    @pulumi.getter(name="aciCniDeployContainer")
    def aci_cni_deploy_container(self) -> Optional[str]:
        """
        Docker image for aci_cni_deploy_container (string)
        """
        return pulumi.get(self, "aci_cni_deploy_container")

    @property
    @pulumi.getter(name="aciControllerContainer")
    def aci_controller_container(self) -> Optional[str]:
        """
        Docker image for aci_controller_container (string)
        """
        return pulumi.get(self, "aci_controller_container")

    @property
    @pulumi.getter(name="aciHostContainer")
    def aci_host_container(self) -> Optional[str]:
        """
        Docker image for aci_host_container (string)
        """
        return pulumi.get(self, "aci_host_container")

    @property
    @pulumi.getter(name="aciMcastContainer")
    def aci_mcast_container(self) -> Optional[str]:
        """
        Docker image for aci_mcast_container (string)
        """
        return pulumi.get(self, "aci_mcast_container")

    @property
    @pulumi.getter(name="aciOpflexContainer")
    def aci_opflex_container(self) -> Optional[str]:
        """
        Docker image for aci_opflex_container (string)
        """
        return pulumi.get(self, "aci_opflex_container")

    @property
    @pulumi.getter(name="aciOvsContainer")
    def aci_ovs_container(self) -> Optional[str]:
        """
        Docker image for aci_ovs_container (string)
        """
        return pulumi.get(self, "aci_ovs_container")

    @property
    @pulumi.getter
    def alpine(self) -> Optional[str]:
        """
        Docker image for alpine (string)
        """
        return pulumi.get(self, "alpine")

    @property
    @pulumi.getter(name="calicoCni")
    def calico_cni(self) -> Optional[str]:
        """
        Docker image for calico_cni (string)
        """
        return pulumi.get(self, "calico_cni")

    @property
    @pulumi.getter(name="calicoControllers")
    def calico_controllers(self) -> Optional[str]:
        """
        Docker image for calico_controllers (string)
        """
        return pulumi.get(self, "calico_controllers")

    @property
    @pulumi.getter(name="calicoCtl")
    def calico_ctl(self) -> Optional[str]:
        """
        Docker image for calico_ctl (string)
        """
        return pulumi.get(self, "calico_ctl")

    @property
    @pulumi.getter(name="calicoFlexVol")
    def calico_flex_vol(self) -> Optional[str]:
        """
        Docker image for calico_flex_vol (string)
        """
        return pulumi.get(self, "calico_flex_vol")

    @property
    @pulumi.getter(name="calicoNode")
    def calico_node(self) -> Optional[str]:
        """
        Docker image for calico_node (string)
        """
        return pulumi.get(self, "calico_node")

    @property
    @pulumi.getter(name="canalCni")
    def canal_cni(self) -> Optional[str]:
        """
        Docker image for canal_cni (string)
        """
        return pulumi.get(self, "canal_cni")

    @property
    @pulumi.getter(name="canalFlannel")
    def canal_flannel(self) -> Optional[str]:
        """
        Docker image for canal_flannel (string)
        """
        return pulumi.get(self, "canal_flannel")

    @property
    @pulumi.getter(name="canalFlexVol")
    def canal_flex_vol(self) -> Optional[str]:
        """
        Docker image for canal_flex_vol (string)
        """
        return pulumi.get(self, "canal_flex_vol")

    @property
    @pulumi.getter(name="canalNode")
    def canal_node(self) -> Optional[str]:
        """
        Docker image for canal_node (string)
        """
        return pulumi.get(self, "canal_node")

    @property
    @pulumi.getter(name="certDownloader")
    def cert_downloader(self) -> Optional[str]:
        """
        Docker image for cert_downloader (string)
        """
        return pulumi.get(self, "cert_downloader")

    @property
    @pulumi.getter
    def coredns(self) -> Optional[str]:
        """
        Docker image for coredns (string)
        """
        return pulumi.get(self, "coredns")

    @property
    @pulumi.getter(name="corednsAutoscaler")
    def coredns_autoscaler(self) -> Optional[str]:
        """
        Docker image for coredns_autoscaler (string)
        """
        return pulumi.get(self, "coredns_autoscaler")

    @property
    @pulumi.getter
    def dnsmasq(self) -> Optional[str]:
        """
        Docker image for dnsmasq (string)
        """
        return pulumi.get(self, "dnsmasq")

    @property
    @pulumi.getter
    def etcd(self) -> Optional[str]:
        """
        Docker image for etcd (string)
        """
        return pulumi.get(self, "etcd")

    @property
    @pulumi.getter
    def flannel(self) -> Optional[str]:
        """
        Docker image for flannel (string)
        """
        return pulumi.get(self, "flannel")

    @property
    @pulumi.getter(name="flannelCni")
    def flannel_cni(self) -> Optional[str]:
        """
        Docker image for flannel_cni (string)
        """
        return pulumi.get(self, "flannel_cni")

    @property
    @pulumi.getter
    def ingress(self) -> Optional[str]:
        """
        RKE k8s cluster ingress controller configuration (list maxitems:1)
        """
        return pulumi.get(self, "ingress")

    @property
    @pulumi.getter(name="ingressBackend")
    def ingress_backend(self) -> Optional[str]:
        """
        Docker image for ingress_backend (string)
        """
        return pulumi.get(self, "ingress_backend")

    @property
    @pulumi.getter(name="kubeDns")
    def kube_dns(self) -> Optional[str]:
        """
        Docker image for kube_dns (string)
        """
        return pulumi.get(self, "kube_dns")

    @property
    @pulumi.getter(name="kubeDnsAutoscaler")
    def kube_dns_autoscaler(self) -> Optional[str]:
        """
        Docker image for kube_dns_autoscaler (string)
        """
        return pulumi.get(self, "kube_dns_autoscaler")

    @property
    @pulumi.getter(name="kubeDnsSidecar")
    def kube_dns_sidecar(self) -> Optional[str]:
        """
        Docker image for kube_dns_sidecar (string)
        """
        return pulumi.get(self, "kube_dns_sidecar")

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[str]:
        """
        Docker image for kubernetes (string)
        """
        return pulumi.get(self, "kubernetes")

    @property
    @pulumi.getter(name="kubernetesServicesSidecar")
    def kubernetes_services_sidecar(self) -> Optional[str]:
        """
        Docker image for kubernetes_services_sidecar (string)
        """
        return pulumi.get(self, "kubernetes_services_sidecar")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[str]:
        """
        Docker image for metrics_server (string)
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter(name="nginxProxy")
    def nginx_proxy(self) -> Optional[str]:
        """
        Docker image for nginx_proxy (string)
        """
        return pulumi.get(self, "nginx_proxy")

    @property
    @pulumi.getter
    def nodelocal(self) -> Optional[str]:
        """
        Docker image for nodelocal (string)
        """
        return pulumi.get(self, "nodelocal")

    @property
    @pulumi.getter(name="podInfraContainer")
    def pod_infra_container(self) -> Optional[str]:
        """
        Docker image for pod_infra_container (string)
        """
        return pulumi.get(self, "pod_infra_container")

    @property
    @pulumi.getter(name="weaveCni")
    def weave_cni(self) -> Optional[str]:
        """
        Docker image for weave_cni (string)
        """
        return pulumi.get(self, "weave_cni")

    @property
    @pulumi.getter(name="weaveNode")
    def weave_node(self) -> Optional[str]:
        """
        Docker image for weave_node (string)
        """
        return pulumi.get(self, "weave_node")

    @property
    @pulumi.getter(name="windowsPodInfraContainer")
    def windows_pod_infra_container(self) -> Optional[str]:
        """
        Docker image for windows_pod_infra_container (string)
        """
        return pulumi.get(self, "windows_pod_infra_container")


@pulumi.output_type
class ClusterUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainInput":
            suggest = "drain_input"
        elif key == "maxUnavailableControlplane":
            suggest = "max_unavailable_controlplane"
        elif key == "maxUnavailableWorker":
            suggest = "max_unavailable_worker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain: Optional[bool] = None,
                 drain_input: Optional['outputs.ClusterUpgradeStrategyDrainInput'] = None,
                 max_unavailable_controlplane: Optional[str] = None,
                 max_unavailable_worker: Optional[str] = None):
        """
        :param bool drain: RKE drain nodes (bool)
        :param 'ClusterUpgradeStrategyDrainInputArgs' drain_input: RKE drain node input (list Maxitems: 1)
        :param str max_unavailable_controlplane: RKE max unavailable controlplane nodes (string)
        :param str max_unavailable_worker: RKE max unavailable worker nodes (string)
        """
        ClusterUpgradeStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            drain=drain,
            drain_input=drain_input,
            max_unavailable_controlplane=max_unavailable_controlplane,
            max_unavailable_worker=max_unavailable_worker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             drain: Optional[bool] = None,
             drain_input: Optional['outputs.ClusterUpgradeStrategyDrainInput'] = None,
             max_unavailable_controlplane: Optional[str] = None,
             max_unavailable_worker: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if drain_input is None and 'drainInput' in kwargs:
            drain_input = kwargs['drainInput']
        if max_unavailable_controlplane is None and 'maxUnavailableControlplane' in kwargs:
            max_unavailable_controlplane = kwargs['maxUnavailableControlplane']
        if max_unavailable_worker is None and 'maxUnavailableWorker' in kwargs:
            max_unavailable_worker = kwargs['maxUnavailableWorker']

        if drain is not None:
            _setter("drain", drain)
        if drain_input is not None:
            _setter("drain_input", drain_input)
        if max_unavailable_controlplane is not None:
            _setter("max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            _setter("max_unavailable_worker", max_unavailable_worker)

    @property
    @pulumi.getter
    def drain(self) -> Optional[bool]:
        """
        RKE drain nodes (bool)
        """
        return pulumi.get(self, "drain")

    @property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> Optional['outputs.ClusterUpgradeStrategyDrainInput']:
        """
        RKE drain node input (list Maxitems: 1)
        """
        return pulumi.get(self, "drain_input")

    @property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[str]:
        """
        RKE max unavailable controlplane nodes (string)
        """
        return pulumi.get(self, "max_unavailable_controlplane")

    @property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[str]:
        """
        RKE max unavailable worker nodes (string)
        """
        return pulumi.get(self, "max_unavailable_worker")


@pulumi.output_type
class ClusterUpgradeStrategyDrainInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteLocalData":
            suggest = "delete_local_data"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "ignoreDaemonSets":
            suggest = "ignore_daemon_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeStrategyDrainInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeStrategyDrainInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeStrategyDrainInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_local_data: Optional[bool] = None,
                 force: Optional[bool] = None,
                 grace_period: Optional[int] = None,
                 ignore_daemon_sets: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param bool delete_local_data: Delete RKE node local data (bool)
        :param bool force: Force RKE node drain (bool)
        :param int grace_period: RKE node drain grace period (int)
        :param bool ignore_daemon_sets: Ignore RKE daemon sets (bool)
        :param int timeout: RKE node drain timeout (int)
        """
        ClusterUpgradeStrategyDrainInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_local_data=delete_local_data,
            force=force,
            grace_period=grace_period,
            ignore_daemon_sets=ignore_daemon_sets,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_local_data: Optional[bool] = None,
             force: Optional[bool] = None,
             grace_period: Optional[int] = None,
             ignore_daemon_sets: Optional[bool] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_local_data is None and 'deleteLocalData' in kwargs:
            delete_local_data = kwargs['deleteLocalData']
        if grace_period is None and 'gracePeriod' in kwargs:
            grace_period = kwargs['gracePeriod']
        if ignore_daemon_sets is None and 'ignoreDaemonSets' in kwargs:
            ignore_daemon_sets = kwargs['ignoreDaemonSets']

        if delete_local_data is not None:
            _setter("delete_local_data", delete_local_data)
        if force is not None:
            _setter("force", force)
        if grace_period is not None:
            _setter("grace_period", grace_period)
        if ignore_daemon_sets is not None:
            _setter("ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[bool]:
        """
        Delete RKE node local data (bool)
        """
        return pulumi.get(self, "delete_local_data")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Force RKE node drain (bool)
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        RKE node drain grace period (int)
        """
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[bool]:
        """
        Ignore RKE daemon sets (bool)
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        RKE node drain timeout (int)
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterWorkerHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWorkerHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWorkerHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWorkerHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 node_name: Optional[str] = None):
        """
        :param str address: Address ip for node (string)
        :param str node_name: Name of the host provisioned via docker machine (string)
        """
        ClusterWorkerHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            node_name=node_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             node_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']

        if address is not None:
            _setter("address", address)
        if node_name is not None:
            _setter("node_name", node_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the host provisioned via docker machine (string)
        """
        return pulumi.get(self, "node_name")


