// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.rke.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterCloudProviderAzureCloudProviderArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterCloudProviderAzureCloudProviderArgs Empty = new ClusterCloudProviderAzureCloudProviderArgs();

    /**
     * The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    @Import(name="aadClientCertPassword")
    private @Nullable Output<String> aadClientCertPassword;

    /**
     * @return The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    public Optional<Output<String>> aadClientCertPassword() {
        return Optional.ofNullable(this.aadClientCertPassword);
    }

    /**
     * The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    @Import(name="aadClientCertPath")
    private @Nullable Output<String> aadClientCertPath;

    /**
     * @return The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    public Optional<Output<String>> aadClientCertPath() {
        return Optional.ofNullable(this.aadClientCertPath);
    }

    /**
     * The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    @Import(name="aadClientId", required=true)
    private Output<String> aadClientId;

    /**
     * @return The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    public Output<String> aadClientId() {
        return this.aadClientId;
    }

    /**
     * The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    @Import(name="aadClientSecret", required=true)
    private Output<String> aadClientSecret;

    /**
     * @return The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
     * 
     */
    public Output<String> aadClientSecret() {
        return this.aadClientSecret;
    }

    /**
     * The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
     * 
     */
    @Import(name="cloud")
    private @Nullable Output<String> cloud;

    /**
     * @return The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
     * 
     */
    public Optional<Output<String>> cloud() {
        return Optional.ofNullable(this.cloud);
    }

    /**
     * Enable exponential backoff to manage resource request retries
     * 
     */
    @Import(name="cloudProviderBackoff")
    private @Nullable Output<Boolean> cloudProviderBackoff;

    /**
     * @return Enable exponential backoff to manage resource request retries
     * 
     */
    public Optional<Output<Boolean>> cloudProviderBackoff() {
        return Optional.ofNullable(this.cloudProviderBackoff);
    }

    /**
     * Backoff duration
     * 
     */
    @Import(name="cloudProviderBackoffDuration")
    private @Nullable Output<Integer> cloudProviderBackoffDuration;

    /**
     * @return Backoff duration
     * 
     */
    public Optional<Output<Integer>> cloudProviderBackoffDuration() {
        return Optional.ofNullable(this.cloudProviderBackoffDuration);
    }

    /**
     * Backoff exponent
     * 
     */
    @Import(name="cloudProviderBackoffExponent")
    private @Nullable Output<Integer> cloudProviderBackoffExponent;

    /**
     * @return Backoff exponent
     * 
     */
    public Optional<Output<Integer>> cloudProviderBackoffExponent() {
        return Optional.ofNullable(this.cloudProviderBackoffExponent);
    }

    /**
     * Backoff jitter
     * 
     */
    @Import(name="cloudProviderBackoffJitter")
    private @Nullable Output<Integer> cloudProviderBackoffJitter;

    /**
     * @return Backoff jitter
     * 
     */
    public Optional<Output<Integer>> cloudProviderBackoffJitter() {
        return Optional.ofNullable(this.cloudProviderBackoffJitter);
    }

    /**
     * Backoff retry limit
     * 
     */
    @Import(name="cloudProviderBackoffRetries")
    private @Nullable Output<Integer> cloudProviderBackoffRetries;

    /**
     * @return Backoff retry limit
     * 
     */
    public Optional<Output<Integer>> cloudProviderBackoffRetries() {
        return Optional.ofNullable(this.cloudProviderBackoffRetries);
    }

    /**
     * Enable rate limiting
     * 
     */
    @Import(name="cloudProviderRateLimit")
    private @Nullable Output<Boolean> cloudProviderRateLimit;

    /**
     * @return Enable rate limiting
     * 
     */
    public Optional<Output<Boolean>> cloudProviderRateLimit() {
        return Optional.ofNullable(this.cloudProviderRateLimit);
    }

    /**
     * (int)
     * 
     */
    @Import(name="cloudProviderRateLimitBucket")
    private @Nullable Output<Integer> cloudProviderRateLimitBucket;

    /**
     * @return (int)
     * 
     */
    public Optional<Output<Integer>> cloudProviderRateLimitBucket() {
        return Optional.ofNullable(this.cloudProviderRateLimitBucket);
    }

    /**
     * Rate limit QPS
     * 
     */
    @Import(name="cloudProviderRateLimitQps")
    private @Nullable Output<Integer> cloudProviderRateLimitQps;

    /**
     * @return Rate limit QPS
     * 
     */
    public Optional<Output<Integer>> cloudProviderRateLimitQps() {
        return Optional.ofNullable(this.cloudProviderRateLimitQps);
    }

    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     * 
     */
    @Import(name="loadBalancerSku")
    private @Nullable Output<String> loadBalancerSku;

    /**
     * @return Load balancer type (basic | standard). Must be standard for auto-scaling
     * 
     */
    public Optional<Output<String>> loadBalancerSku() {
        return Optional.ofNullable(this.loadBalancerSku);
    }

    /**
     * The location of the resource group that the cluster is deployed in
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return The location of the resource group that the cluster is deployed in
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
     * 
     */
    @Import(name="maximumLoadBalancerRuleCount")
    private @Nullable Output<Integer> maximumLoadBalancerRuleCount;

    /**
     * @return Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
     * 
     */
    public Optional<Output<Integer>> maximumLoadBalancerRuleCount() {
        return Optional.ofNullable(this.maximumLoadBalancerRuleCount);
    }

    /**
     * The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
     * 
     */
    @Import(name="primaryAvailabilitySetName")
    private @Nullable Output<String> primaryAvailabilitySetName;

    /**
     * @return The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
     * 
     */
    public Optional<Output<String>> primaryAvailabilitySetName() {
        return Optional.ofNullable(this.primaryAvailabilitySetName);
    }

    /**
     * The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
     * 
     */
    @Import(name="primaryScaleSetName")
    private @Nullable Output<String> primaryScaleSetName;

    /**
     * @return The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
     * 
     */
    public Optional<Output<String>> primaryScaleSetName() {
        return Optional.ofNullable(this.primaryScaleSetName);
    }

    /**
     * The name of the resource group that the cluster is deployed in
     * 
     */
    @Import(name="resourceGroup")
    private @Nullable Output<String> resourceGroup;

    /**
     * @return The name of the resource group that the cluster is deployed in
     * 
     */
    public Optional<Output<String>> resourceGroup() {
        return Optional.ofNullable(this.resourceGroup);
    }

    /**
     * (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
     * 
     */
    @Import(name="routeTableName")
    private @Nullable Output<String> routeTableName;

    /**
     * @return (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
     * 
     */
    public Optional<Output<String>> routeTableName() {
        return Optional.ofNullable(this.routeTableName);
    }

    /**
     * The name of the security group attached to the cluster&#39;s subnet
     * 
     */
    @Import(name="securityGroupName")
    private @Nullable Output<String> securityGroupName;

    /**
     * @return The name of the security group attached to the cluster&#39;s subnet
     * 
     */
    public Optional<Output<String>> securityGroupName() {
        return Optional.ofNullable(this.securityGroupName);
    }

    /**
     * The name of the Subnet that the cluster is deployed in
     * 
     */
    @Import(name="subnetName")
    private @Nullable Output<String> subnetName;

    /**
     * @return The name of the Subnet that the cluster is deployed in
     * 
     */
    public Optional<Output<String>> subnetName() {
        return Optional.ofNullable(this.subnetName);
    }

    /**
     * The ID of the Azure Subscription that the cluster is deployed in
     * 
     */
    @Import(name="subscriptionId", required=true)
    private Output<String> subscriptionId;

    /**
     * @return The ID of the Azure Subscription that the cluster is deployed in
     * 
     */
    public Output<String> subscriptionId() {
        return this.subscriptionId;
    }

    /**
     * The AAD Tenant ID for the Subscription that the cluster is deployed in
     * 
     */
    @Import(name="tenantId", required=true)
    private Output<String> tenantId;

    /**
     * @return The AAD Tenant ID for the Subscription that the cluster is deployed in
     * 
     */
    public Output<String> tenantId() {
        return this.tenantId;
    }

    /**
     * Use instance metadata service where possible
     * 
     */
    @Import(name="useInstanceMetadata")
    private @Nullable Output<Boolean> useInstanceMetadata;

    /**
     * @return Use instance metadata service where possible
     * 
     */
    public Optional<Output<Boolean>> useInstanceMetadata() {
        return Optional.ofNullable(this.useInstanceMetadata);
    }

    /**
     * Use managed service identity for the virtual machine to access Azure ARM APIs
     * 
     */
    @Import(name="useManagedIdentityExtension")
    private @Nullable Output<Boolean> useManagedIdentityExtension;

    /**
     * @return Use managed service identity for the virtual machine to access Azure ARM APIs
     * 
     */
    public Optional<Output<Boolean>> useManagedIdentityExtension() {
        return Optional.ofNullable(this.useManagedIdentityExtension);
    }

    /**
     * The type of azure nodes. If not set, it will be default to standard.
     * 
     */
    @Import(name="vmType")
    private @Nullable Output<String> vmType;

    /**
     * @return The type of azure nodes. If not set, it will be default to standard.
     * 
     */
    public Optional<Output<String>> vmType() {
        return Optional.ofNullable(this.vmType);
    }

    /**
     * The name of the VNet that the cluster is deployed in
     * 
     */
    @Import(name="vnetName")
    private @Nullable Output<String> vnetName;

    /**
     * @return The name of the VNet that the cluster is deployed in
     * 
     */
    public Optional<Output<String>> vnetName() {
        return Optional.ofNullable(this.vnetName);
    }

    /**
     * The name of the resource group that the Vnet is deployed in
     * 
     */
    @Import(name="vnetResourceGroup")
    private @Nullable Output<String> vnetResourceGroup;

    /**
     * @return The name of the resource group that the Vnet is deployed in
     * 
     */
    public Optional<Output<String>> vnetResourceGroup() {
        return Optional.ofNullable(this.vnetResourceGroup);
    }

    private ClusterCloudProviderAzureCloudProviderArgs() {}

    private ClusterCloudProviderAzureCloudProviderArgs(ClusterCloudProviderAzureCloudProviderArgs $) {
        this.aadClientCertPassword = $.aadClientCertPassword;
        this.aadClientCertPath = $.aadClientCertPath;
        this.aadClientId = $.aadClientId;
        this.aadClientSecret = $.aadClientSecret;
        this.cloud = $.cloud;
        this.cloudProviderBackoff = $.cloudProviderBackoff;
        this.cloudProviderBackoffDuration = $.cloudProviderBackoffDuration;
        this.cloudProviderBackoffExponent = $.cloudProviderBackoffExponent;
        this.cloudProviderBackoffJitter = $.cloudProviderBackoffJitter;
        this.cloudProviderBackoffRetries = $.cloudProviderBackoffRetries;
        this.cloudProviderRateLimit = $.cloudProviderRateLimit;
        this.cloudProviderRateLimitBucket = $.cloudProviderRateLimitBucket;
        this.cloudProviderRateLimitQps = $.cloudProviderRateLimitQps;
        this.loadBalancerSku = $.loadBalancerSku;
        this.location = $.location;
        this.maximumLoadBalancerRuleCount = $.maximumLoadBalancerRuleCount;
        this.primaryAvailabilitySetName = $.primaryAvailabilitySetName;
        this.primaryScaleSetName = $.primaryScaleSetName;
        this.resourceGroup = $.resourceGroup;
        this.routeTableName = $.routeTableName;
        this.securityGroupName = $.securityGroupName;
        this.subnetName = $.subnetName;
        this.subscriptionId = $.subscriptionId;
        this.tenantId = $.tenantId;
        this.useInstanceMetadata = $.useInstanceMetadata;
        this.useManagedIdentityExtension = $.useManagedIdentityExtension;
        this.vmType = $.vmType;
        this.vnetName = $.vnetName;
        this.vnetResourceGroup = $.vnetResourceGroup;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterCloudProviderAzureCloudProviderArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterCloudProviderAzureCloudProviderArgs $;

        public Builder() {
            $ = new ClusterCloudProviderAzureCloudProviderArgs();
        }

        public Builder(ClusterCloudProviderAzureCloudProviderArgs defaults) {
            $ = new ClusterCloudProviderAzureCloudProviderArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param aadClientCertPassword The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientCertPassword(@Nullable Output<String> aadClientCertPassword) {
            $.aadClientCertPassword = aadClientCertPassword;
            return this;
        }

        /**
         * @param aadClientCertPassword The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientCertPassword(String aadClientCertPassword) {
            return aadClientCertPassword(Output.of(aadClientCertPassword));
        }

        /**
         * @param aadClientCertPath The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientCertPath(@Nullable Output<String> aadClientCertPath) {
            $.aadClientCertPath = aadClientCertPath;
            return this;
        }

        /**
         * @param aadClientCertPath The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientCertPath(String aadClientCertPath) {
            return aadClientCertPath(Output.of(aadClientCertPath));
        }

        /**
         * @param aadClientId The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientId(Output<String> aadClientId) {
            $.aadClientId = aadClientId;
            return this;
        }

        /**
         * @param aadClientId The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientId(String aadClientId) {
            return aadClientId(Output.of(aadClientId));
        }

        /**
         * @param aadClientSecret The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientSecret(Output<String> aadClientSecret) {
            $.aadClientSecret = aadClientSecret;
            return this;
        }

        /**
         * @param aadClientSecret The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
         * 
         * @return builder
         * 
         */
        public Builder aadClientSecret(String aadClientSecret) {
            return aadClientSecret(Output.of(aadClientSecret));
        }

        /**
         * @param cloud The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
         * 
         * @return builder
         * 
         */
        public Builder cloud(@Nullable Output<String> cloud) {
            $.cloud = cloud;
            return this;
        }

        /**
         * @param cloud The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
         * 
         * @return builder
         * 
         */
        public Builder cloud(String cloud) {
            return cloud(Output.of(cloud));
        }

        /**
         * @param cloudProviderBackoff Enable exponential backoff to manage resource request retries
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoff(@Nullable Output<Boolean> cloudProviderBackoff) {
            $.cloudProviderBackoff = cloudProviderBackoff;
            return this;
        }

        /**
         * @param cloudProviderBackoff Enable exponential backoff to manage resource request retries
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoff(Boolean cloudProviderBackoff) {
            return cloudProviderBackoff(Output.of(cloudProviderBackoff));
        }

        /**
         * @param cloudProviderBackoffDuration Backoff duration
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffDuration(@Nullable Output<Integer> cloudProviderBackoffDuration) {
            $.cloudProviderBackoffDuration = cloudProviderBackoffDuration;
            return this;
        }

        /**
         * @param cloudProviderBackoffDuration Backoff duration
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffDuration(Integer cloudProviderBackoffDuration) {
            return cloudProviderBackoffDuration(Output.of(cloudProviderBackoffDuration));
        }

        /**
         * @param cloudProviderBackoffExponent Backoff exponent
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffExponent(@Nullable Output<Integer> cloudProviderBackoffExponent) {
            $.cloudProviderBackoffExponent = cloudProviderBackoffExponent;
            return this;
        }

        /**
         * @param cloudProviderBackoffExponent Backoff exponent
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffExponent(Integer cloudProviderBackoffExponent) {
            return cloudProviderBackoffExponent(Output.of(cloudProviderBackoffExponent));
        }

        /**
         * @param cloudProviderBackoffJitter Backoff jitter
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffJitter(@Nullable Output<Integer> cloudProviderBackoffJitter) {
            $.cloudProviderBackoffJitter = cloudProviderBackoffJitter;
            return this;
        }

        /**
         * @param cloudProviderBackoffJitter Backoff jitter
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffJitter(Integer cloudProviderBackoffJitter) {
            return cloudProviderBackoffJitter(Output.of(cloudProviderBackoffJitter));
        }

        /**
         * @param cloudProviderBackoffRetries Backoff retry limit
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffRetries(@Nullable Output<Integer> cloudProviderBackoffRetries) {
            $.cloudProviderBackoffRetries = cloudProviderBackoffRetries;
            return this;
        }

        /**
         * @param cloudProviderBackoffRetries Backoff retry limit
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderBackoffRetries(Integer cloudProviderBackoffRetries) {
            return cloudProviderBackoffRetries(Output.of(cloudProviderBackoffRetries));
        }

        /**
         * @param cloudProviderRateLimit Enable rate limiting
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimit(@Nullable Output<Boolean> cloudProviderRateLimit) {
            $.cloudProviderRateLimit = cloudProviderRateLimit;
            return this;
        }

        /**
         * @param cloudProviderRateLimit Enable rate limiting
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimit(Boolean cloudProviderRateLimit) {
            return cloudProviderRateLimit(Output.of(cloudProviderRateLimit));
        }

        /**
         * @param cloudProviderRateLimitBucket (int)
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimitBucket(@Nullable Output<Integer> cloudProviderRateLimitBucket) {
            $.cloudProviderRateLimitBucket = cloudProviderRateLimitBucket;
            return this;
        }

        /**
         * @param cloudProviderRateLimitBucket (int)
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimitBucket(Integer cloudProviderRateLimitBucket) {
            return cloudProviderRateLimitBucket(Output.of(cloudProviderRateLimitBucket));
        }

        /**
         * @param cloudProviderRateLimitQps Rate limit QPS
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimitQps(@Nullable Output<Integer> cloudProviderRateLimitQps) {
            $.cloudProviderRateLimitQps = cloudProviderRateLimitQps;
            return this;
        }

        /**
         * @param cloudProviderRateLimitQps Rate limit QPS
         * 
         * @return builder
         * 
         */
        public Builder cloudProviderRateLimitQps(Integer cloudProviderRateLimitQps) {
            return cloudProviderRateLimitQps(Output.of(cloudProviderRateLimitQps));
        }

        /**
         * @param loadBalancerSku Load balancer type (basic | standard). Must be standard for auto-scaling
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSku(@Nullable Output<String> loadBalancerSku) {
            $.loadBalancerSku = loadBalancerSku;
            return this;
        }

        /**
         * @param loadBalancerSku Load balancer type (basic | standard). Must be standard for auto-scaling
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSku(String loadBalancerSku) {
            return loadBalancerSku(Output.of(loadBalancerSku));
        }

        /**
         * @param location The location of the resource group that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location The location of the resource group that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param maximumLoadBalancerRuleCount Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
         * 
         * @return builder
         * 
         */
        public Builder maximumLoadBalancerRuleCount(@Nullable Output<Integer> maximumLoadBalancerRuleCount) {
            $.maximumLoadBalancerRuleCount = maximumLoadBalancerRuleCount;
            return this;
        }

        /**
         * @param maximumLoadBalancerRuleCount Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
         * 
         * @return builder
         * 
         */
        public Builder maximumLoadBalancerRuleCount(Integer maximumLoadBalancerRuleCount) {
            return maximumLoadBalancerRuleCount(Output.of(maximumLoadBalancerRuleCount));
        }

        /**
         * @param primaryAvailabilitySetName The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
         * 
         * @return builder
         * 
         */
        public Builder primaryAvailabilitySetName(@Nullable Output<String> primaryAvailabilitySetName) {
            $.primaryAvailabilitySetName = primaryAvailabilitySetName;
            return this;
        }

        /**
         * @param primaryAvailabilitySetName The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
         * 
         * @return builder
         * 
         */
        public Builder primaryAvailabilitySetName(String primaryAvailabilitySetName) {
            return primaryAvailabilitySetName(Output.of(primaryAvailabilitySetName));
        }

        /**
         * @param primaryScaleSetName The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
         * 
         * @return builder
         * 
         */
        public Builder primaryScaleSetName(@Nullable Output<String> primaryScaleSetName) {
            $.primaryScaleSetName = primaryScaleSetName;
            return this;
        }

        /**
         * @param primaryScaleSetName The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
         * 
         * @return builder
         * 
         */
        public Builder primaryScaleSetName(String primaryScaleSetName) {
            return primaryScaleSetName(Output.of(primaryScaleSetName));
        }

        /**
         * @param resourceGroup The name of the resource group that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder resourceGroup(@Nullable Output<String> resourceGroup) {
            $.resourceGroup = resourceGroup;
            return this;
        }

        /**
         * @param resourceGroup The name of the resource group that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder resourceGroup(String resourceGroup) {
            return resourceGroup(Output.of(resourceGroup));
        }

        /**
         * @param routeTableName (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder routeTableName(@Nullable Output<String> routeTableName) {
            $.routeTableName = routeTableName;
            return this;
        }

        /**
         * @param routeTableName (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder routeTableName(String routeTableName) {
            return routeTableName(Output.of(routeTableName));
        }

        /**
         * @param securityGroupName The name of the security group attached to the cluster&#39;s subnet
         * 
         * @return builder
         * 
         */
        public Builder securityGroupName(@Nullable Output<String> securityGroupName) {
            $.securityGroupName = securityGroupName;
            return this;
        }

        /**
         * @param securityGroupName The name of the security group attached to the cluster&#39;s subnet
         * 
         * @return builder
         * 
         */
        public Builder securityGroupName(String securityGroupName) {
            return securityGroupName(Output.of(securityGroupName));
        }

        /**
         * @param subnetName The name of the Subnet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder subnetName(@Nullable Output<String> subnetName) {
            $.subnetName = subnetName;
            return this;
        }

        /**
         * @param subnetName The name of the Subnet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder subnetName(String subnetName) {
            return subnetName(Output.of(subnetName));
        }

        /**
         * @param subscriptionId The ID of the Azure Subscription that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder subscriptionId(Output<String> subscriptionId) {
            $.subscriptionId = subscriptionId;
            return this;
        }

        /**
         * @param subscriptionId The ID of the Azure Subscription that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder subscriptionId(String subscriptionId) {
            return subscriptionId(Output.of(subscriptionId));
        }

        /**
         * @param tenantId The AAD Tenant ID for the Subscription that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder tenantId(Output<String> tenantId) {
            $.tenantId = tenantId;
            return this;
        }

        /**
         * @param tenantId The AAD Tenant ID for the Subscription that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder tenantId(String tenantId) {
            return tenantId(Output.of(tenantId));
        }

        /**
         * @param useInstanceMetadata Use instance metadata service where possible
         * 
         * @return builder
         * 
         */
        public Builder useInstanceMetadata(@Nullable Output<Boolean> useInstanceMetadata) {
            $.useInstanceMetadata = useInstanceMetadata;
            return this;
        }

        /**
         * @param useInstanceMetadata Use instance metadata service where possible
         * 
         * @return builder
         * 
         */
        public Builder useInstanceMetadata(Boolean useInstanceMetadata) {
            return useInstanceMetadata(Output.of(useInstanceMetadata));
        }

        /**
         * @param useManagedIdentityExtension Use managed service identity for the virtual machine to access Azure ARM APIs
         * 
         * @return builder
         * 
         */
        public Builder useManagedIdentityExtension(@Nullable Output<Boolean> useManagedIdentityExtension) {
            $.useManagedIdentityExtension = useManagedIdentityExtension;
            return this;
        }

        /**
         * @param useManagedIdentityExtension Use managed service identity for the virtual machine to access Azure ARM APIs
         * 
         * @return builder
         * 
         */
        public Builder useManagedIdentityExtension(Boolean useManagedIdentityExtension) {
            return useManagedIdentityExtension(Output.of(useManagedIdentityExtension));
        }

        /**
         * @param vmType The type of azure nodes. If not set, it will be default to standard.
         * 
         * @return builder
         * 
         */
        public Builder vmType(@Nullable Output<String> vmType) {
            $.vmType = vmType;
            return this;
        }

        /**
         * @param vmType The type of azure nodes. If not set, it will be default to standard.
         * 
         * @return builder
         * 
         */
        public Builder vmType(String vmType) {
            return vmType(Output.of(vmType));
        }

        /**
         * @param vnetName The name of the VNet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder vnetName(@Nullable Output<String> vnetName) {
            $.vnetName = vnetName;
            return this;
        }

        /**
         * @param vnetName The name of the VNet that the cluster is deployed in
         * 
         * @return builder
         * 
         */
        public Builder vnetName(String vnetName) {
            return vnetName(Output.of(vnetName));
        }

        /**
         * @param vnetResourceGroup The name of the resource group that the Vnet is deployed in
         * 
         * @return builder
         * 
         */
        public Builder vnetResourceGroup(@Nullable Output<String> vnetResourceGroup) {
            $.vnetResourceGroup = vnetResourceGroup;
            return this;
        }

        /**
         * @param vnetResourceGroup The name of the resource group that the Vnet is deployed in
         * 
         * @return builder
         * 
         */
        public Builder vnetResourceGroup(String vnetResourceGroup) {
            return vnetResourceGroup(Output.of(vnetResourceGroup));
        }

        public ClusterCloudProviderAzureCloudProviderArgs build() {
            if ($.aadClientId == null) {
                throw new MissingRequiredPropertyException("ClusterCloudProviderAzureCloudProviderArgs", "aadClientId");
            }
            if ($.aadClientSecret == null) {
                throw new MissingRequiredPropertyException("ClusterCloudProviderAzureCloudProviderArgs", "aadClientSecret");
            }
            if ($.subscriptionId == null) {
                throw new MissingRequiredPropertyException("ClusterCloudProviderAzureCloudProviderArgs", "subscriptionId");
            }
            if ($.tenantId == null) {
                throw new MissingRequiredPropertyException("ClusterCloudProviderAzureCloudProviderArgs", "tenantId");
            }
            return $;
        }
    }

}
