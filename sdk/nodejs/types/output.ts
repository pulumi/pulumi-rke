// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterAuthentication {
    /**
     * List of additional hostnames and IPs to include in the api server PKI cert
     */
    sans: string[];
    /**
     * Authentication strategy that will be used in RKE k8s cluster
     */
    strategy?: string;
    /**
     * Webhook configuration options
     */
    webhook: outputs.ClusterAuthenticationWebhook;
}

export interface ClusterAuthenticationWebhook {
    /**
     * Controls how long to cache authentication decisions
     */
    cacheTimeout?: string;
    /**
     * Multiline string that represent a custom webhook config file
     */
    configFile?: string;
}

export interface ClusterAuthorization {
    mode?: string;
    /**
     * Authorization mode options
     */
    options?: {[key: string]: any};
}

export interface ClusterBastionHost {
    /**
     * Address of Bastion Host
     */
    address: string;
    /**
     * Ignore proxy env vars at Bastion Host?
     */
    ignoreProxyEnvVars?: boolean;
    /**
     * SSH Port of Bastion Host
     */
    port?: string;
    /**
     * SSH Agent Auth enable (bool)
     */
    sshAgentAuth: boolean;
    /**
     * SSH Certificate Key
     */
    sshCert?: string;
    /**
     * SSH Certificate Path (string)
     */
    sshCertPath: string;
    /**
     * SSH Private Key
     */
    sshKey?: string;
    /**
     * SSH Private Key Path (string)
     */
    sshKeyPath: string;
    /**
     * SSH User to Bastion Host
     */
    user: string;
}

export interface ClusterCertificate {
    certificate: string;
    commonName: string;
    config: string;
    configEnvName: string;
    configPath: string;
    envName: string;
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    key: string;
    keyEnvName: string;
    keyPath: string;
    name: string;
    ouName: string;
    path: string;
}

export interface ClusterCloudProvider {
    /**
     * @deprecated Use awsCloudProvider instead
     */
    awsCloudConfig?: outputs.ClusterCloudProviderAwsCloudConfig;
    /**
     * AWS Cloud Provider config
     */
    awsCloudProvider?: outputs.ClusterCloudProviderAwsCloudProvider;
    /**
     * @deprecated Use azureCloudProvider instead
     */
    azureCloudConfig?: outputs.ClusterCloudProviderAzureCloudConfig;
    /**
     * Azure Cloud Provider config
     */
    azureCloudProvider?: outputs.ClusterCloudProviderAzureCloudProvider;
    /**
     * @deprecated Use customCloudProvider instead
     */
    customCloudConfig?: string;
    /**
     * Custom Cloud Provider config
     */
    customCloudProvider?: string;
    name: string;
    /**
     * @deprecated Use openstackCloudProvider instead
     */
    openstackCloudConfig?: outputs.ClusterCloudProviderOpenstackCloudConfig;
    /**
     * Openstack Cloud Provider config
     */
    openstackCloudProvider?: outputs.ClusterCloudProviderOpenstackCloudProvider;
    /**
     * @deprecated Use vsphereCloudProvider instead
     */
    vsphereCloudConfig?: outputs.ClusterCloudProviderVsphereCloudConfig;
    /**
     * Vsphere Cloud Provider config
     */
    vsphereCloudProvider?: outputs.ClusterCloudProviderVsphereCloudProvider;
}

export interface ClusterCloudProviderAwsCloudConfig {
    global?: outputs.ClusterCloudProviderAwsCloudConfigGlobal;
    serviceOverrides?: outputs.ClusterCloudProviderAwsCloudConfigServiceOverride[];
}

export interface ClusterCloudProviderAwsCloudConfigGlobal {
    /**
     * Disables the automatic ingress creation
     */
    disableSecurityGroupIngress?: boolean;
    /**
     * Setting this to true will disable the check and provide a warning that the check was skipped
     */
    disableStrictZoneCheck?: boolean;
    /**
     * Use these ELB security groups instead create new
     */
    elbSecurityGroup?: string;
    /**
     * The cluster id we'll use to identify our cluster resources
     */
    kubernetesClusterId?: string;
    /**
     * Legacy cluster id we'll use to identify our cluster resources
     */
    kubernetesClusterTag?: string;
    /**
     * IAM role to assume when interaction with AWS APIs
     */
    roleArn?: string;
    /**
     * Enables using a specific RouteTable
     */
    routeTableId?: string;
    /**
     * Enables using a specific subnet to use for ELB's
     */
    subnetId?: string;
    /**
     * The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided
     */
    vpc?: string;
    /**
     * The AWS zone
     */
    zone?: string;
}

export interface ClusterCloudProviderAwsCloudConfigServiceOverride {
    /**
     * @deprecated Use service instead
     */
    key?: string;
    region?: string;
    service: string;
    signingMethod: string;
    signingName?: string;
    signingRegion?: string;
    url?: string;
}

export interface ClusterCloudProviderAwsCloudProvider {
    global?: outputs.ClusterCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterCloudProviderAwsCloudProviderGlobal {
    /**
     * Disables the automatic ingress creation
     */
    disableSecurityGroupIngress?: boolean;
    /**
     * Setting this to true will disable the check and provide a warning that the check was skipped
     */
    disableStrictZoneCheck?: boolean;
    /**
     * Use these ELB security groups instead create new
     */
    elbSecurityGroup?: string;
    /**
     * The cluster id we'll use to identify our cluster resources
     */
    kubernetesClusterId?: string;
    /**
     * Legacy cluster id we'll use to identify our cluster resources
     */
    kubernetesClusterTag?: string;
    /**
     * IAM role to assume when interaction with AWS APIs
     */
    roleArn?: string;
    /**
     * Enables using a specific RouteTable
     */
    routeTableId?: string;
    /**
     * Enables using a specific subnet to use for ELB's
     */
    subnetId?: string;
    /**
     * The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided
     */
    vpc?: string;
    /**
     * The AWS zone
     */
    zone?: string;
}

export interface ClusterCloudProviderAwsCloudProviderServiceOverride {
    /**
     * @deprecated Use service instead
     */
    key?: string;
    region?: string;
    service: string;
    signingMethod: string;
    signingName?: string;
    signingRegion?: string;
    url?: string;
}

export interface ClusterCloudProviderAzureCloudConfig {
    /**
     * The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientCertPassword?: string;
    /**
     * The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientCertPath?: string;
    /**
     * The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientId: string;
    /**
     * The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientSecret: string;
    /**
     * The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
     */
    cloud?: string;
    /**
     * Enable exponential backoff to manage resource request retries
     */
    cloudProviderBackoff?: boolean;
    /**
     * Backoff duration
     */
    cloudProviderBackoffDuration?: number;
    /**
     * Backoff exponent
     */
    cloudProviderBackoffExponent?: number;
    /**
     * Backoff jitter
     */
    cloudProviderBackoffJitter?: number;
    /**
     * Backoff retry limit
     */
    cloudProviderBackoffRetries?: number;
    /**
     * Enable rate limiting
     */
    cloudProviderRateLimit?: boolean;
    cloudProviderRateLimitBucket: number;
    /**
     * Rate limit QPS
     */
    cloudProviderRateLimitQps?: number;
    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     */
    loadBalancerSku?: string;
    /**
     * The location of the resource group that the cluster is deployed in
     */
    location?: string;
    /**
     * Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
     */
    maximumLoadBalancerRuleCount?: number;
    /**
     * The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
     */
    primaryAvailabilitySetName?: string;
    /**
     * The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
     */
    primaryScaleSetName?: string;
    /**
     * The name of the resource group that the cluster is deployed in
     */
    resourceGroup?: string;
    /**
     * (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
     */
    routeTableName?: string;
    /**
     * The name of the security group attached to the cluster's subnet
     */
    securityGroupName?: string;
    /**
     * The name of the Subnet that the cluster is deployed in
     */
    subnetName?: string;
    /**
     * The ID of the Azure Subscription that the cluster is deployed in
     */
    subscriptionId: string;
    /**
     * The AAD Tenant ID for the Subscription that the cluster is deployed in
     */
    tenantId: string;
    /**
     * Use instance metadata service where possible
     */
    useInstanceMetadata?: boolean;
    /**
     * Use managed service identity for the virtual machine to access Azure ARM APIs
     */
    useManagedIdentityExtension?: boolean;
    /**
     * The type of azure nodes. If not set, it will be default to standard.
     */
    vmType?: string;
    /**
     * The name of the VNet that the cluster is deployed in
     */
    vnetName?: string;
    /**
     * The name of the resource group that the Vnet is deployed in
     */
    vnetResourceGroup?: string;
}

export interface ClusterCloudProviderAzureCloudProvider {
    /**
     * The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientCertPassword?: string;
    /**
     * The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientCertPath?: string;
    /**
     * The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientId: string;
    /**
     * The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
     */
    aadClientSecret: string;
    /**
     * The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
     */
    cloud?: string;
    /**
     * Enable exponential backoff to manage resource request retries
     */
    cloudProviderBackoff?: boolean;
    /**
     * Backoff duration
     */
    cloudProviderBackoffDuration?: number;
    /**
     * Backoff exponent
     */
    cloudProviderBackoffExponent?: number;
    /**
     * Backoff jitter
     */
    cloudProviderBackoffJitter?: number;
    /**
     * Backoff retry limit
     */
    cloudProviderBackoffRetries?: number;
    /**
     * Enable rate limiting
     */
    cloudProviderRateLimit?: boolean;
    cloudProviderRateLimitBucket: number;
    /**
     * Rate limit QPS
     */
    cloudProviderRateLimitQps?: number;
    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     */
    loadBalancerSku?: string;
    /**
     * The location of the resource group that the cluster is deployed in
     */
    location?: string;
    /**
     * Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
     */
    maximumLoadBalancerRuleCount?: number;
    /**
     * The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
     */
    primaryAvailabilitySetName?: string;
    /**
     * The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
     */
    primaryScaleSetName?: string;
    /**
     * The name of the resource group that the cluster is deployed in
     */
    resourceGroup?: string;
    /**
     * (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
     */
    routeTableName?: string;
    /**
     * The name of the security group attached to the cluster's subnet
     */
    securityGroupName?: string;
    /**
     * The name of the Subnet that the cluster is deployed in
     */
    subnetName?: string;
    /**
     * The ID of the Azure Subscription that the cluster is deployed in
     */
    subscriptionId: string;
    /**
     * The AAD Tenant ID for the Subscription that the cluster is deployed in
     */
    tenantId: string;
    /**
     * Use instance metadata service where possible
     */
    useInstanceMetadata?: boolean;
    /**
     * Use managed service identity for the virtual machine to access Azure ARM APIs
     */
    useManagedIdentityExtension?: boolean;
    /**
     * The type of azure nodes. If not set, it will be default to standard.
     */
    vmType?: string;
    /**
     * The name of the VNet that the cluster is deployed in
     */
    vnetName?: string;
    /**
     * The name of the resource group that the Vnet is deployed in
     */
    vnetResourceGroup?: string;
}

export interface ClusterCloudProviderOpenstackCloudConfig {
    blockStorage: outputs.ClusterCloudProviderOpenstackCloudConfigBlockStorage;
    global: outputs.ClusterCloudProviderOpenstackCloudConfigGlobal;
    loadBalancer: outputs.ClusterCloudProviderOpenstackCloudConfigLoadBalancer;
    metadata: outputs.ClusterCloudProviderOpenstackCloudConfigMetadata;
    route: outputs.ClusterCloudProviderOpenstackCloudConfigRoute;
}

export interface ClusterCloudProviderOpenstackCloudConfigBlockStorage {
    bsVersion?: string;
    ignoreVolumeAz?: boolean;
    trustDevicePath?: boolean;
}

export interface ClusterCloudProviderOpenstackCloudConfigGlobal {
    authUrl: string;
    caFile?: string;
    domainId?: string;
    domainName?: string;
    password: string;
    region?: string;
    tenantId?: string;
    tenantName?: string;
    trustId?: string;
    userId?: string;
    username?: string;
}

export interface ClusterCloudProviderOpenstackCloudConfigLoadBalancer {
    createMonitor?: boolean;
    floatingNetworkId?: string;
    lbMethod?: string;
    lbProvider?: string;
    lbVersion?: string;
    manageSecurityGroups?: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId?: string;
    useOctavia?: boolean;
}

export interface ClusterCloudProviderOpenstackCloudConfigMetadata {
    requestTimeout?: number;
    searchOrder?: string;
}

export interface ClusterCloudProviderOpenstackCloudConfigRoute {
    routerId?: string;
}

export interface ClusterCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.ClusterCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.ClusterCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.ClusterCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.ClusterCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion?: string;
    ignoreVolumeAz?: boolean;
    trustDevicePath?: boolean;
}

export interface ClusterCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile?: string;
    domainId?: string;
    domainName?: string;
    password: string;
    region?: string;
    tenantId?: string;
    tenantName?: string;
    trustId?: string;
    userId?: string;
    username?: string;
}

export interface ClusterCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor?: boolean;
    floatingNetworkId?: string;
    lbMethod?: string;
    lbProvider?: string;
    lbVersion?: string;
    manageSecurityGroups?: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId?: string;
    useOctavia?: boolean;
}

export interface ClusterCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout?: number;
    searchOrder?: string;
}

export interface ClusterCloudProviderOpenstackCloudProviderRoute {
    routerId?: string;
}

export interface ClusterCloudProviderVsphereCloudConfig {
    disk: outputs.ClusterCloudProviderVsphereCloudConfigDisk;
    global: outputs.ClusterCloudProviderVsphereCloudConfigGlobal;
    /**
     * RKE k8s cluster network configuration (list maxitems:1)
     */
    network: outputs.ClusterCloudProviderVsphereCloudConfigNetwork;
    virtualCenters: outputs.ClusterCloudProviderVsphereCloudConfigVirtualCenter[];
    workspace: outputs.ClusterCloudProviderVsphereCloudConfigWorkspace;
}

export interface ClusterCloudProviderVsphereCloudConfigDisk {
    scsiControllerType?: string;
}

export interface ClusterCloudProviderVsphereCloudConfigGlobal {
    datacenter?: string;
    datacenters: string;
    datastore?: string;
    insecureFlag?: boolean;
    password?: string;
    port?: string;
    soapRoundtripCount?: number;
    user?: string;
    vmName?: string;
    vmUuid?: string;
    workingDir?: string;
}

export interface ClusterCloudProviderVsphereCloudConfigNetwork {
    publicNetwork?: string;
}

export interface ClusterCloudProviderVsphereCloudConfigVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port?: string;
    soapRoundtripCount?: number;
    user: string;
}

export interface ClusterCloudProviderVsphereCloudConfigWorkspace {
    datacenter: string;
    defaultDatastore?: string;
    folder?: string;
    resourcepoolPath?: string;
    server: string;
}

export interface ClusterCloudProviderVsphereCloudProvider {
    disk: outputs.ClusterCloudProviderVsphereCloudProviderDisk;
    global: outputs.ClusterCloudProviderVsphereCloudProviderGlobal;
    /**
     * RKE k8s cluster network configuration (list maxitems:1)
     */
    network: outputs.ClusterCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterCloudProviderVsphereCloudProviderDisk {
    scsiControllerType?: string;
}

export interface ClusterCloudProviderVsphereCloudProviderGlobal {
    datacenter?: string;
    datacenters: string;
    datastore?: string;
    insecureFlag?: boolean;
    password?: string;
    port?: string;
    soapRoundtripCount?: number;
    user?: string;
    vmName?: string;
    vmUuid?: string;
    workingDir?: string;
}

export interface ClusterCloudProviderVsphereCloudProviderNetwork {
    publicNetwork?: string;
}

export interface ClusterCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port?: string;
    soapRoundtripCount?: number;
    user: string;
}

export interface ClusterCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore?: string;
    folder?: string;
    resourcepoolPath?: string;
    server: string;
}

export interface ClusterControlPlaneHost {
    address: string;
    nodeName: string;
}

export interface ClusterDns {
    /**
     * NodeSelector key pair
     */
    nodeSelector?: {[key: string]: any};
    /**
     * Nodelocal dns
     */
    nodelocal?: outputs.ClusterDnsNodelocal;
    /**
     * DNS provider
     */
    provider?: string;
    /**
     * ReverseCIDRs
     */
    reverseCidrs?: string[];
    /**
     * Upstream nameservers
     */
    upstreamNameservers?: string[];
}

export interface ClusterDnsNodelocal {
    ipAddress?: string;
    /**
     * Node selector key pair
     */
    nodeSelector?: {[key: string]: any};
}

export interface ClusterEtcdHost {
    address: string;
    nodeName: string;
}

export interface ClusterInactiveHost {
    address: string;
    nodeName: string;
}

export interface ClusterIngress {
    /**
     * Ingress Default Backend
     */
    defaultBackend?: boolean;
    /**
     * Ingress controller dns policy
     */
    dnsPolicy?: string;
    /**
     * Extra arguments for the ingress controller
     */
    extraArgs?: {[key: string]: any};
    /**
     * Ingress controller http port
     */
    httpPort?: number;
    /**
     * Ingress controller https port
     */
    httpsPort?: number;
    /**
     * Ingress controller network mode
     */
    networkMode?: string;
    /**
     * Node selector key pair
     */
    nodeSelector?: {[key: string]: any};
    /**
     * Ingress controller options
     */
    options?: {[key: string]: any};
    /**
     * Ingress controller provider
     */
    provider?: string;
}

export interface ClusterMonitoring {
    /**
     * Node selector key pair
     */
    nodeSelector?: {[key: string]: any};
    /**
     * Monitoring options
     */
    options?: {[key: string]: any};
    /**
     * Monitoring provider
     */
    provider: string;
}

export interface ClusterNetwork {
    /**
     * Aci network provider config
     */
    aciNetworkProvider?: outputs.ClusterNetworkAciNetworkProvider;
    /**
     * Calico network provider config
     */
    calicoNetworkProvider?: outputs.ClusterNetworkCalicoNetworkProvider;
    /**
     * Canal network provider config
     */
    canalNetworkProvider?: outputs.ClusterNetworkCanalNetworkProvider;
    /**
     * Flannel network provider config
     */
    flannelNetworkProvider?: outputs.ClusterNetworkFlannelNetworkProvider;
    /**
     * Network provider MTU
     */
    mtu?: number;
    /**
     * Network provider options
     */
    options: {[key: string]: any};
    /**
     * Network provider plugin
     */
    plugin?: string;
    /**
     * Weave network provider config
     */
    weaveNetworkProvider?: outputs.ClusterNetworkWeaveNetworkProvider;
}

export interface ClusterNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    encapType: string;
    externDynamic: string;
    externStatic: string;
    infraVlan: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    mcastRangeEnd: string;
    mcastRangeStart: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    serviceVlan: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    systemId: string;
    token: string;
    vrfName: string;
    vrfTenant: string;
}

export interface ClusterNetworkCalicoNetworkProvider {
    /**
     * RKE k8s cluster cloud provider configuration [rke-cloud-providers](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/) (list maxitems:1)
     */
    cloudProvider: string;
}

export interface ClusterNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterNode {
    /**
     * IP or FQDN that is fully resolvable and used for SSH communication
     */
    address: string;
    /**
     * Docker socket on the node that will be used in tunneling
     */
    dockerSocket?: string;
    /**
     * Hostname override
     */
    hostnameOverride?: string;
    /**
     * Internal address that will be used for components communication
     */
    internalAddress?: string;
    /**
     * Node Labels
     */
    labels?: {[key: string]: any};
    /**
     * Name of the host provisioned via docker machine
     */
    nodeName?: string;
    /**
     * Port used for SSH communication
     */
    port?: string;
    /**
     * Node roles in k8s cluster [controlplane/worker/etcd])
     */
    roles: string[];
    /**
     * Node role in kubernetes cluster [controlplane/worker/etcd], specified by a comma-separated string
     *
     * @deprecated Use role instead
     */
    rolesDeprecated?: string;
    /**
     * SSH Agent Auth enable (bool)
     */
    sshAgentAuth: boolean;
    /**
     * SSH Certificate
     */
    sshCert?: string;
    /**
     * SSH Certificate Path (string)
     */
    sshCertPath?: string;
    /**
     * SSH Private Key
     */
    sshKey?: string;
    /**
     * SSH Private Key Path (string)
     */
    sshKeyPath?: string;
    /**
     * Node taints
     */
    taints?: outputs.ClusterNodeTaint[];
    /**
     * SSH user that will be used by RKE
     */
    user: string;
}

export interface ClusterNodeTaint {
    effect?: string;
    key: string;
    value: string;
}

export interface ClusterPrivateRegistry {
    /**
     * Set as default registry
     */
    isDefault?: boolean;
    /**
     * Registry password
     */
    password?: string;
    /**
     * Registry URL
     */
    url: string;
    /**
     * Registry user
     */
    user?: string;
}

export interface ClusterRestore {
    /**
     * RKE k8s cluster restore configuration (list maxitems:1)
     */
    restore?: boolean;
    /**
     * Snapshot name
     */
    snapshotName?: string;
}

export interface ClusterRotateCertificates {
    /**
     * Rotate CA Certificates
     */
    caCertificates?: boolean;
    /**
     * RKE k8s cluster services (list maxitems:1)
     */
    services?: string[];
}

export interface ClusterRunningSystemImage {
    aciCniDeployContainer?: string;
    aciControllerContainer?: string;
    aciHostContainer?: string;
    aciMcastContainer?: string;
    aciOpflexContainer?: string;
    aciOvsContainer?: string;
    alpine?: string;
    calicoCni?: string;
    calicoControllers?: string;
    calicoCtl?: string;
    calicoFlexVol?: string;
    calicoNode?: string;
    canalCni?: string;
    canalFlannel?: string;
    canalFlexVol?: string;
    canalNode?: string;
    certDownloader?: string;
    coredns?: string;
    corednsAutoscaler?: string;
    dnsmasq?: string;
    etcd?: string;
    flannel?: string;
    flannelCni?: string;
    /**
     * RKE k8s cluster ingress controller configuration (list maxitems:1)
     */
    ingress?: string;
    ingressBackend?: string;
    kubeDns?: string;
    kubeDnsAutoscaler?: string;
    kubeDnsSidecar?: string;
    kubernetes?: string;
    kubernetesServicesSidecar?: string;
    metricsServer?: string;
    nginxProxy?: string;
    nodelocal?: string;
    podInfraContainer?: string;
    weaveCni?: string;
    weaveNode?: string;
    windowsPodInfraContainer?: string;
}

export interface ClusterServices {
    etcd: outputs.ClusterServicesEtcd;
    kubeApi: outputs.ClusterServicesKubeApi;
    kubeController: outputs.ClusterServicesKubeController;
    kubelet: outputs.ClusterServicesKubelet;
    kubeproxy: outputs.ClusterServicesKubeproxy;
    scheduler: outputs.ClusterServicesScheduler;
}

export interface ClusterServicesEtcd {
    backupConfig: outputs.ClusterServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls: string[];
    extraArgs: {[key: string]: any};
    extraBinds: string[];
    extraEnvs: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot?: boolean;
    uid?: number;
}

export interface ClusterServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout?: number;
}

export interface ClusterServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName?: string;
    customCa?: string;
    endpoint?: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterServicesEtcdDeprecated {
    backupConfig: outputs.ClusterServicesEtcdDeprecatedBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls: string[];
    extraArgs: {[key: string]: any};
    extraBinds: string[];
    extraEnvs: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot?: boolean;
    uid?: number;
}

export interface ClusterServicesEtcdDeprecatedBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout?: number;
}

export interface ClusterServicesEtcdDeprecatedBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName?: string;
    customCa?: string;
    endpoint?: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterServicesKubeApi {
    /**
     * Enable/Disable AlwaysPullImages admissions plugin
     */
    alwaysPullImages: boolean;
    auditLog: outputs.ClusterServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterServicesKubeApiEventRateLimit;
    /**
     * Extra arguments that are added to the kube-api services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    image: string;
    /**
     * Built-in PodSecurityPolicy (privileged or restricted)
     */
    podSecurityConfiguration: string;
    /**
     * Enabled/Disable PodSecurityPolicy
     */
    podSecurityPolicy: boolean;
    secretsEncryptionConfig?: outputs.ClusterServicesKubeApiSecretsEncryptionConfig;
    /**
     * Virtual IP range that will be used by Kubernetes services
     */
    serviceClusterIpRange: string;
    /**
     * Port range for services defined with NodePort type
     */
    serviceNodePortRange: string;
}

export interface ClusterServicesKubeApiAuditLog {
    configuration: outputs.ClusterServicesKubeApiAuditLogConfiguration;
    enabled: boolean;
}

export interface ClusterServicesKubeApiAuditLogConfiguration {
    format: string;
    maxAge: number;
    maxBackup: number;
    maxSize: number;
    path: string;
    policy: string;
}

export interface ClusterServicesKubeApiDeprecated {
    /**
     * Enable/Disable AlwaysPullImages admissions plugin
     */
    alwaysPullImages: boolean;
    auditLog: outputs.ClusterServicesKubeApiDeprecatedAuditLog;
    eventRateLimit?: outputs.ClusterServicesKubeApiDeprecatedEventRateLimit;
    /**
     * Extra arguments that are added to the kube-api services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    image: string;
    /**
     * Built-in PodSecurityPolicy (privileged or restricted)
     */
    podSecurityConfiguration: string;
    /**
     * Enabled/Disable PodSecurityPolicy
     */
    podSecurityPolicy: boolean;
    secretsEncryptionConfig?: outputs.ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig;
    /**
     * Virtual IP range that will be used by Kubernetes services
     */
    serviceClusterIpRange: string;
    /**
     * Port range for services defined with NodePort type
     */
    serviceNodePortRange: string;
}

export interface ClusterServicesKubeApiDeprecatedAuditLog {
    configuration: outputs.ClusterServicesKubeApiDeprecatedAuditLogConfiguration;
    enabled: boolean;
}

export interface ClusterServicesKubeApiDeprecatedAuditLogConfiguration {
    format: string;
    maxAge: number;
    maxBackup: number;
    maxSize: number;
    path: string;
    policy: string;
}

export interface ClusterServicesKubeApiDeprecatedEventRateLimit {
    configuration: string;
    enabled: boolean;
}

export interface ClusterServicesKubeApiDeprecatedSecretsEncryptionConfig {
    customConfig: string;
    enabled: boolean;
}

export interface ClusterServicesKubeApiEventRateLimit {
    configuration: string;
    enabled: boolean;
}

export interface ClusterServicesKubeApiSecretsEncryptionConfig {
    customConfig: string;
    enabled: boolean;
}

export interface ClusterServicesKubeController {
    /**
     * (Computed) RKE k8s cluster cidr (string)
     */
    clusterCidr: string;
    /**
     * Extra arguments that are added to the kube-controller service
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the kube-controller service
     */
    image: string;
    /**
     * Virtual IP range that will be used by Kubernetes services
     */
    serviceClusterIpRange: string;
}

export interface ClusterServicesKubeControllerDeprecated {
    /**
     * (Computed) RKE k8s cluster cidr (string)
     */
    clusterCidr: string;
    /**
     * Extra arguments that are added to the kube-controller service
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the kube-controller service
     */
    image: string;
    /**
     * Virtual IP range that will be used by Kubernetes services
     */
    serviceClusterIpRange: string;
}

export interface ClusterServicesKubeProxyDeprecated {
    /**
     * Extra arguments that are added to the kubeproxy services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the worker nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the worker nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the kubeproxy service
     */
    image: string;
}

export interface ClusterServicesKubeSchedulerDeprecated {
    /**
     * Extra arguments that are added to the scheduler services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the scheduler service
     */
    image: string;
}

export interface ClusterServicesKubelet {
    /**
     * (Computed) RKE k8s cluster dns server (string)
     */
    clusterDnsServer: string;
    /**
     * (Computed) RKE k8s cluster domain (string)
     */
    clusterDomain?: string;
    /**
     * Extra arguments that are added to the kubelet services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the worker nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the nodes
     */
    extraEnvs: string[];
    /**
     * Fail if swap is enabled
     */
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    /**
     * Docker image of the kubelet service
     */
    image: string;
    /**
     * The image whose network/ipc namespaces containers in each pod will use
     */
    infraContainerImage: string;
}

export interface ClusterServicesKubeletDeprecated {
    /**
     * (Computed) RKE k8s cluster dns server (string)
     */
    clusterDnsServer: string;
    /**
     * (Computed) RKE k8s cluster domain (string)
     */
    clusterDomain?: string;
    /**
     * Extra arguments that are added to the kubelet services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the worker nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the nodes
     */
    extraEnvs: string[];
    /**
     * Fail if swap is enabled
     */
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    /**
     * Docker image of the kubelet service
     */
    image: string;
    /**
     * The image whose network/ipc namespaces containers in each pod will use
     */
    infraContainerImage: string;
}

export interface ClusterServicesKubeproxy {
    /**
     * Extra arguments that are added to the kubeproxy services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the worker nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the worker nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the kubeproxy service
     */
    image: string;
}

export interface ClusterServicesScheduler {
    /**
     * Extra arguments that are added to the scheduler services
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds added to the controlplane nodes
     */
    extraBinds: string[];
    /**
     * Extra env added to the controlplane nodes
     */
    extraEnvs: string[];
    /**
     * Docker image of the scheduler service
     */
    image: string;
}

export interface ClusterSystemImages {
    aciCniDeployContainer?: string;
    aciControllerContainer?: string;
    aciHostContainer?: string;
    aciMcastContainer?: string;
    aciOpflexContainer?: string;
    aciOvsContainer?: string;
    alpine?: string;
    calicoCni?: string;
    calicoControllers?: string;
    calicoCtl?: string;
    calicoFlexVol?: string;
    calicoNode?: string;
    canalCni?: string;
    canalFlannel?: string;
    canalFlexVol?: string;
    canalNode?: string;
    certDownloader?: string;
    coredns?: string;
    corednsAutoscaler?: string;
    dnsmasq?: string;
    etcd?: string;
    flannel?: string;
    flannelCni?: string;
    /**
     * RKE k8s cluster ingress controller configuration (list maxitems:1)
     */
    ingress?: string;
    ingressBackend?: string;
    kubeDns?: string;
    kubeDnsAutoscaler?: string;
    kubeDnsSidecar?: string;
    kubernetes?: string;
    kubernetesServicesSidecar?: string;
    metricsServer?: string;
    nginxProxy?: string;
    nodelocal?: string;
    podInfraContainer?: string;
    weaveCni?: string;
    weaveNode?: string;
    windowsPodInfraContainer?: string;
}

export interface ClusterUpgradeStrategy {
    drain: boolean;
    drainInput: outputs.ClusterUpgradeStrategyDrainInput;
    maxUnavailableControlplane: string;
    maxUnavailableWorker: string;
}

export interface ClusterUpgradeStrategyDrainInput {
    deleteLocalData: boolean;
    force: boolean;
    gracePeriod: number;
    ignoreDaemonSets: boolean;
    timeout: number;
}

export interface ClusterWorkerHost {
    address: string;
    nodeName: string;
}

